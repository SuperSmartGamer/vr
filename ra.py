#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
tmate-bootstrap: A comprehensive, all-in-one script to install, configure,
manage, and monitor a persistent tmate session as a systemd service.

This script is designed for maximum compatibility and robustness, relying only
on the Python standard library. It handles everything from downloading the
correct tmate binary to generating and managing the systemd service.
"""

import subprocess
import os
import time
import shutil
import platform
import sys
import urllib.request
import json
import tarfile
import traceback

# --- Global Configuration ---
TMATE_INSTALL_DIR = "/usr/local/bin"
TMATE_EXECUTABLE_PATH = os.path.join(TMATE_INSTALL_DIR, "tmate")
SERVICE_BASE_DIR = "/opt/tmate_monitor"
TMATE_CONFIG_FILE = os.path.join(SERVICE_BASE_DIR, ".tmate.conf")
TMATE_SOCKET_PATH = "/tmp/tmate.sock"
URL_OUTPUT_FILE = os.path.join(SERVICE_BASE_DIR, "session_urls.txt")
UPLOAD_SCRIPT_PATH = os.path.join(SERVICE_BASE_DIR, "uploader.py")
SYSTEMD_SERVICE_NAME = "tmate-monitor.service"
SYSTEMD_SERVICE_PATH = f"/etc/systemd/system/{SYSTEMD_SERVICE_NAME}"
GITHUB_API_URL = "https://api.github.com/repos/tmate-io/tmate/releases/latest"

# --- Content for Generated Files ---

# A minimal tmate configuration to ensure non-interactive, predictable behavior.
TMATE_CONFIG_CONTENT = """
# Generated by tmate-bootstrap
set-option -g default-command "bash"
set -g display-time 4000
set -g escape-time 0
set -g remain-on-exit off
set -g status off
"""

# Placeholder for the user's cloud upload script.
UPLOADER_PLACEHOLDER_CONTENT = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
This is a placeholder for your cloud upload script.
You MUST replace the logic in `upload_file` with your actual implementation
for uploading to a service like Cloudflare R2, AWS S3, etc.
"""

import os
import sys

def upload_file(file_path):
    """
    Uploads the given file to your cloud storage.

    Args:
        file_path (str): The absolute path to the file to upload.

    Returns:
        bool: True on success, False on failure.
    """
    print(f"[UPLOADER] Simulating upload of {file_path}...")

    # --- START: YOUR CUSTOM UPLOAD LOGIC ---
    # This is where you implement the actual upload.
    # Example for Cloudflare R2 using boto3:
    #
    # Ensure you have boto3 installed: pip install boto3
    #
    # import boto3
    # from botocore.exceptions import NoCredentialsError, PartialCredentialsError
    #
    # try:
    #     account_id = os.environ.get("R2_ACCOUNT_ID")
    #     access_key_id = os.environ.get("R2_ACCESS_KEY_ID")
    #     access_key_secret = os.environ.get("R2_SECRET_ACCESS_KEY")
    #     bucket_name = os.environ.get("R2_BUCKET_NAME")
    #
    #     if not all([account_id, access_key_id, access_key_secret, bucket_name]):
    #         print("[UPLOADER_ERROR] Missing one or more R2 environment variables.", file=sys.stderr)
    #         return False
    #
    #     s3 = boto3.client(
    #         service_name='s3',
    #         endpoint_url=f'https://{account_id}.r2.cloudflarestorage.com',
    #         aws_access_key_id=access_key_id,
    #         aws_secret_access_key=access_key_secret,
    #         region_name='auto'
    #     )
    #
    #     object_name = os.path.basename(file_path)
    #     s3.upload_file(file_path, bucket_name, object_name)
    #     print(f"[UPLOADER] Successfully uploaded {object_name} to bucket {bucket_name}.")
    #     return True
    #
    # except (NoCredentialsError, PartialCredentialsError) as e:
    #     print(f"[UPLOADER_ERROR] Credentials error: {e}", file=sys.stderr)
    #     return False
    # except Exception as e:
    #     print(f"[UPLOADER_ERROR] An unexpected error occurred: {e}", file=sys.stderr)
    #     return False
    #
    # --- END: YOUR CUSTOM UPLOAD LOGIC ---

    print(f"[UPLOADER] Simulation complete. Remember to replace this with real logic.")
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1:
        upload_file(sys.argv[1])
    else:
        print("Usage: ./uploader.py <file_to_upload>")
'''

# --- Logging Utilities ---
def log(level, message, exc_info=False):
    """Unified logger."""
    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{level.upper()}] {timestamp} {message}", file=sys.stderr if level.lower() in ['error', 'warning'] else sys.stdout)
    if exc_info:
        traceback.print_exc(file=sys.stderr)

# --- Core Subprocess Runner ---
def run_cmd(cmd, check=True, timeout=60):
    """A wrapper for subprocess.run with unified logging and error handling."""
    try:
        log('cmd', f"Executing: {' '.join(cmd)}")
        # Use Popen to handle stdout/stderr streaming if needed, but run is simpler for now
        result = subprocess.run(cmd, capture_output=True, text=True, check=check, timeout=timeout)
        return result.stdout.strip()
    except FileNotFoundError:
        log('error', f"Command not found: {cmd[0]}. Is it in your system's PATH?")
        return None
    except subprocess.CalledProcessError as e:
        # Log non-zero exit codes as warnings instead of errors for commands like pkill
        log_level = 'warning' if 'pkill' in cmd[0] else 'error'
        log(log_level, f"Command '{' '.join(cmd)}' returned non-zero exit code {e.returncode}.")
        if e.stderr:
            log(log_level, f"Stderr: {e.stderr.strip()}")
        return None # Indicate failure
    except subprocess.TimeoutExpired:
        log('error', f"Command '{' '.join(cmd)}' timed out after {timeout} seconds.")
        return None
    except Exception:
        log('error', f"An unexpected exception occurred while running command.", exc_info=True)
        return None

# --- Action Functions ---

def action_install():
    """
    Downloads, extracts, and installs the latest tmate binary with redundancy.
    """
    log('info', "Starting robust tmate installation...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False

    # 1. Fetch release data with retries
    release_info = None
    for attempt in range(3):
        try:
            log('info', f"Fetching latest tmate release from GitHub (Attempt {attempt + 1}/3)...")
            with urllib.request.urlopen(GITHUB_API_URL, timeout=20) as response:
                if response.status == 200:
                    release_info = json.loads(response.read().decode())
                    break
                log('warning', f"GitHub API returned status {response.status}.")
        except Exception as e:
            log('warning', f"Failed to fetch release data: {e}")
        time.sleep(5)
    
    if not release_info:
        log('error', "Could not fetch release data from GitHub after multiple attempts.")
        return False

    # 2. Determine correct binary URL with flexible matching
    system = platform.system()
    machine = platform.machine()
    arch_aliases = {"x86_64": ["amd64", "x86_64"], "aarch64": ["arm64", "aarch64"]}
    
    if system != "Linux" or machine not in arch_aliases:
        log('error', f"Unsupported OS/Architecture: {system}/{machine}.")
        return False

    download_url = None
    for asset in release_info.get("assets", []):
        name = asset["name"].lower()
        is_linux = "linux" in name
        is_correct_arch = any(arch in name for arch in arch_aliases[machine])
        is_supported_archive = name.endswith((".tar.xz", ".tar.gz"))

        if is_linux and is_correct_arch and is_supported_archive:
            download_url = asset["browser_download_url"]
            log('info', f"Found suitable asset: {asset['name']}")
            break

    if not download_url:
        log('error', f"Could not find a suitable tmate binary for your architecture ({machine}).")
        return False

    # 3. Clean up previous installation
    log('info', "Cleaning up old tmate processes and files...")
    run_cmd(["pkill", "-f", "tmate"], check=False)
    time.sleep(1)
    if os.path.exists(TMATE_EXECUTABLE_PATH):
        os.remove(TMATE_EXECUTABLE_PATH)

    # 4. Download and extract
    archive_path = f"/tmp/{download_url.split('/')[-1]}"
    extract_path = "/tmp/tmate_extract"
    try:
        log('info', f"Downloading from {download_url}...")
        urllib.request.urlretrieve(download_url, archive_path)
        
        if os.path.exists(extract_path): shutil.rmtree(extract_path)
        os.makedirs(extract_path)

        log('info', f"Extracting archive {archive_path}...")
        with tarfile.open(archive_path) as tar:
            tar.extractall(path=extract_path)

        extracted_binary = next((os.path.join(r, f) for r, _, files in os.walk(extract_path) for f in files if f == 'tmate'), None)
        if not extracted_binary:
            log('error', "Could not find 'tmate' executable in the downloaded archive.")
            return False

        log('info', f"Installing tmate to {TMATE_EXECUTABLE_PATH}...")
        shutil.move(extracted_binary, TMATE_EXECUTABLE_PATH)
        os.chmod(TMATE_EXECUTABLE_PATH, 0o755)

    except Exception:
        log('error', "An error occurred during download or extraction.", exc_info=True)
        return False
    finally:
        if os.path.exists(archive_path): os.remove(archive_path)
        if os.path.exists(extract_path): shutil.rmtree(extract_path)

    # 5. Verify installation robustly
    log('info', "Verifying tmate installation...")
    if not os.path.exists(TMATE_EXECUTABLE_PATH):
        log('error', "Verification failed: tmate executable not found at the installation path.")
        return False
        
    version = run_cmd([TMATE_EXECUTABLE_PATH, "-V"])
    if not (version and "tmate" in version):
        log('error', "Verification failed: 'tmate -V' did not return expected output.")
        return False

    log('info', f"tmate installation successful! Version: {version}")
    return True

def action_setup_service():
    """Creates directories, config files, and the systemd service file."""
    log('info', "Setting up service directories and files...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False
    
    if not os.path.exists(TMATE_EXECUTABLE_PATH):
        log('error', f"tmate is not installed at {TMATE_EXECUTABLE_PATH}. Please run the 'install' action first.")
        return False

    try:
        os.makedirs(SERVICE_BASE_DIR, 0o755, exist_ok=True)
        with open(TMATE_CONFIG_FILE, 'w') as f:
            f.write(TMATE_CONFIG_CONTENT)
        log('info', f"Created tmate config at {TMATE_CONFIG_FILE}")

        if not os.path.exists(UPLOAD_SCRIPT_PATH):
            with open(UPLOAD_SCRIPT_PATH, 'w') as f:
                f.write(UPLOADER_PLACEHOLDER_CONTENT)
            os.chmod(UPLOAD_SCRIPT_PATH, 0o755)
            log('warning', f"Created placeholder uploader at {UPLOAD_SCRIPT_PATH}. You MUST edit it with your cloud credentials.")

        script_path = os.path.realpath(__file__)
        service_content = f"""[Unit]
Description=Persistent tmate Session Monitor
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
Group=root
ExecStart=/usr/bin/python3 {script_path} run
WorkingDirectory={SERVICE_BASE_DIR}
Environment="PYTHONUNBUFFERED=1"
Restart=always
RestartSec=30
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
"""
        with open(SYSTEMD_SERVICE_PATH, 'w') as f:
            f.write(service_content)
        log('info', f"Created systemd service file at {SYSTEMD_SERVICE_PATH}")

        log('info', "Reloading systemd daemon...")
        run_cmd(["systemctl", "daemon-reload"])
        
        log('info', "\nSetup complete! To start the service, run:")
        log('info', f"  sudo systemctl enable --now {SYSTEMD_SERVICE_NAME}")
        return True
    except Exception:
        log('error', "An error occurred during service setup.", exc_info=True)
        return False

def get_tmate_links():
    """Retrieves all session URLs from a running tmate daemon."""
    links = {}
    keys = {
        "Web Session (R/W)": "#{tmate_web}",
        "Web Session (RO)": "#{tmate_web_ro}",
        "SSH Session (R/W)": "#{tmate_ssh}",
        "SSH Session (RO)": "#{tmate_ssh_ro}",
    }
    for name, key in keys.items():
        cmd = [TMATE_EXECUTABLE_PATH, "-S", TMATE_SOCKET_PATH, "display", "-p", key]
        link = run_cmd(cmd, check=False) # Check=False because it can return empty if not ready
        if link and ("ssh" in link or "https" in link):
            links[name] = link
    return links if len(links) == len(keys) else None

def action_run_monitor():
    """The main monitoring loop executed by the systemd service."""
    log('info', "tmate monitor started. Entering main loop...")
    while True:
        try:
            links = get_tmate_links()

            if not links:
                log('warning', "tmate session not found or unresponsive. Starting a new one.")
                run_cmd(["pkill", "-f", "tmate"], check=False)
                if os.path.exists(TMATE_SOCKET_PATH): os.remove(TMATE_SOCKET_PATH)
                time.sleep(2)

                start_cmd = [
                    TMATE_EXECUTABLE_PATH, "-S", TMATE_SOCKET_PATH,
                    "-f", TMATE_CONFIG_FILE,
                    "new-session", "-d"
                ]
                if run_cmd(start_cmd) is None:
                    log('error', "Failed to start new tmate session. Will retry.")
                    time.sleep(60)
                    continue
                
                log('info', "New session created. Waiting for it to connect...")
                time.sleep(15)
                links = get_tmate_links()

            if links:
                log('info', "Successfully retrieved session URLs.")
                content = "\n".join([f"{name}: {url}" for name, url in links.items()])
                with open(URL_OUTPUT_FILE, 'w') as f: f.write(content + "\n")
                
                if os.path.exists(UPLOAD_SCRIPT_PATH):
                    log('info', "Executing uploader script...")
                    run_cmd([UPLOAD_SCRIPT_PATH, URL_OUTPUT_FILE], check=False)
            else:
                log('error', "Failed to retrieve session links after start. The session may be unstable.")

        except Exception:
            log('error', "An unhandled error occurred in the monitor loop.", exc_info=True)

        log('info', f"Check complete. Next check in 5 minutes.")
        time.sleep(300)

def action_status():
    """Checks the status of the service and the tmate session."""
    log('info', "Checking tmate service status...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges for full status check.")
        return False
        
    service_active = run_cmd(["systemctl", "is-active", SYSTEMD_SERVICE_NAME], check=False)
    print(f"\n--- Service Status ---")
    print(f"Service ({SYSTEMD_SERVICE_NAME}) is: {service_active}")

    print(f"\n--- tmate Session Status ---")
    links = get_tmate_links()
    if links:
        print("tmate session is ACTIVE. URLs:")
        for name, url in links.items():
            print(f"  {name}: {url}")
    else:
        print("tmate session is INACTIVE or not responding.")

    print("\nTo see detailed service logs, run:")
    print(f"  journalctl -u {SYSTEMD_SERVICE_NAME} -n 50 -f\n")
    return True

def action_uninstall():
    """Completely removes the tmate binary, service, and all related files."""
    log('info', "Starting uninstallation...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False

    if os.path.exists(SYSTEMD_SERVICE_PATH):
        log('info', f"Stopping and disabling {SYSTEMD_SERVICE_NAME} service...")
        run_cmd(["systemctl", "stop", SYSTEMD_SERVICE_NAME], check=False)
        run_cmd(["systemctl", "disable", SYSTEMD_SERVICE_NAME], check=False)
        os.remove(SYSTEMD_SERVICE_PATH)
        run_cmd(["systemctl", "daemon-reload"])
        run_cmd(["systemctl", "reset-failed"], check=False)

    run_cmd(["pkill", "-f", "tmate"], check=False)

    if os.path.exists(TMATE_EXECUTABLE_PATH):
        log('info', f"Removing tmate binary: {TMATE_EXECUTABLE_PATH}")
        os.remove(TMATE_EXECUTABLE_PATH)
    if os.path.exists(SERVICE_BASE_DIR):
        log('info', f"Removing service directory: {SERVICE_BASE_DIR}")
        shutil.rmtree(SERVICE_BASE_DIR)
    if os.path.exists(TMATE_SOCKET_PATH):
        os.remove(TMATE_SOCKET_PATH)

    log('info', "Uninstallation complete.")
    return True

def main():
    """Main command-line interface."""
    actions = {
        "install": action_install,
        "setup-service": action_setup_service,
        "run": action_run_monitor,
        "uninstall": action_uninstall,
        "status": action_status,
    }
    
    if len(sys.argv) < 2 or sys.argv[1] not in actions:
        print("\ntmate-bootstrap: All-in-one tmate service manager")
        print("\nUsage: sudo ./tmate_bootstrap.py [ACTION]")
        print("\nActions:")
        print("  install        - Downloads and installs the latest tmate binary.")
        print("  setup-service  - Creates configs and the systemd service file.")
        print("  status         - Checks the current status of the service and session.")
        print("  uninstall      - Removes the tmate binary and all service files.")
        print("  run            - (Internal) Starts the monitoring loop for the service.")
        print("\nRecommended Workflow:")
        print("  1. sudo ./tmate_bootstrap.py install")
        print("  2. sudo ./tmate_bootstrap.py setup-service")
        print("  3. Edit /opt/tmate_monitor/uploader.py with your cloud credentials.")
        print("  4. sudo systemctl enable --now tmate-monitor.service")
        print("  5. sudo ./tmate_bootstrap.py status")
        sys.exit(1)

    # Rename script for user convenience
    if not __file__.endswith('tmate_bootstrap.py'):
        try:
            new_name = os.path.join(os.path.dirname(__file__), 'tmate_bootstrap.py')
            shutil.move(__file__, new_name)
            log('info', f"Renamed script to 'tmate_bootstrap.py' for clarity. Please use the new name.")
            # Exit so the user can re-run with the new name
            sys.exit(0)
        except Exception:
             # Fails silently if permissions are an issue, not critical
             pass


    action = sys.argv[1]
    func = actions[action]
    if not func():
        log('error', f"Action '{action}' failed. Please check the logs above.")
        sys.exit(1)
    log('info', f"Action '{action}' completed successfully.")

if __name__ == "__main__":
    main()

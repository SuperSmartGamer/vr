import subprocess
import os
import re
import time
import shutil
import platform
import sys
import urllib.request
import json
import tarfile
import traceback

# --- Configuration ---
TMATE_INSTALL_DIR = "/usr/local/bin"
TMATE_CONFIG_FILE = "/root/.tmate.conf" # tmate will look for this by default when run as root
TMATE_RELEASE_URL = "https://api.github.com/repos/tmate-io/tmate/releases/latest"
SERVICE_BASE_DIR = "/opt/tmate_monitor"
SHS_FILE_PATH = os.path.join(SERVICE_BASE_DIR, "shs.txt")

SYSTEMD_SERVICE_NAME = "tmate_monitor.service"

TMATE_CONFIG_CONTENT = """
# ~/.tmate.conf - Automatically generated by Python script for root user
# This file is placed in /root/ and tmate is expected to load it by default.
# Unbind the keybinding for killing a session (Ctrl+b &)
unbind-key &

# Unbind the keybinding for killing a window/pane (Ctrl+b x)
unbind-key x

# Disable the timeout for displaying messages (e.g., SSH/web links)
# This keeps the links visible longer on screen if an interactive session were attached.
set -g display-time 0
"""

# Dummy content for upload.py if the user doesn't provide their own
DUMMY_UPLOAD_CONTENT = """
# This is a placeholder for your R2 upload script.
# You MUST replace this with your actual Cloudflare R2 upload logic.

def upload_to_r2(file_path):
    print(f"[UPLOAD] Simulating upload of {file_path} to Cloudflare R2...")
    # --- YOUR ACTUAL R2 UPLOAD LOGIC GOES HERE ---
    # Example (using boto3, assuming credentials/config are set up):
    # import boto3
    # s3_client = boto3.client(
    #     's3',
    #     endpoint_url='YOUR_R2_ENDPOINT_URL', # e.g., https://<ACCOUNT_ID>.r2.cloudflarestorage.com
    #     aws_access_key_id='YOUR_R2_ACCESS_KEY_ID',
    #     aws_secret_access_key='YOUR_R2_SECRET_ACCESS_KEY'
    # )
    # try:
    #     bucket_name = 'YOUR_R2_BUCKET_NAME'
    #     object_name = os.path.basename(file_path) # or a more complex path like 'tmate_urls/shs.txt'
    #     s3_client.upload_file(file_path, bucket_name, object_name)
    #     print(f"[UPLOAD] Successfully uploaded {object_name} to R2 bucket {bucket_name}.")
    #     return True
    # except Exception as e:
    #     print(f"[UPLOAD_ERROR] Failed to upload to R2: {e}")
    #     return False
    # -----------------------------------------------
    print(f"[UPLOAD] Simulation successful for {file_path}. Please replace this with real logic.")
    return True
"""


def log_message(message):
    """Prints a message to stdout, suitable for console and journalctl."""
    print(f"[INFO] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_warning(message):
    """Prints a warning message to stdout."""
    print(f"[WARNING] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_error(message, include_traceback=False):
    """Prints an error message to stderr, optionally with traceback."""
    print(f"[ERROR] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}", file=sys.stderr)
    if include_traceback:
        print(traceback.format_exc(), file=sys.stderr)

def run_command(cmd, check_output=False, shell=False, sudo=False):
    """
    Helper to run shell commands, with enhanced error logging.
    Gracefully handles pkill returning exit code 1 (no process found).
    """
    full_cmd = ["sudo"] + cmd if sudo else cmd
    cmd_str = ' '.join(full_cmd) if isinstance(full_cmd, list) else full_cmd
    log_message(f"Executing: {cmd_str}")
    try:
        if check_output:
            result = subprocess.run(full_cmd, check=True, capture_output=True, text=True, shell=shell, timeout=60)
            log_message(f"Command output:\n{result.stdout.strip()}")
            return result.stdout.strip()
        else:
            result = subprocess.run(full_cmd, check=True, shell=shell, timeout=60)
            log_message(f"Command '{cmd_str}' completed successfully.")
            return True
    except subprocess.CalledProcessError as e:
        # Special handling for pkill returning 1 (no process found)
        if "pkill" in cmd_str and e.returncode == 1:
            log_message(f"Command '{cmd_str}' completed with exit code 1 (no matching processes found, which is often expected).")
            return True # Treat as success in this specific case
        else:
            log_error(f"Command '{cmd_str}' failed with exit code {e.returncode}.")
            if e.stdout: log_error(f"Stdout: {e.stdout.strip()}")
            if e.stderr: log_error(f"Stderr: {e.stderr.strip()}")
            return False
    except FileNotFoundError:
        log_error(f"Command '{full_cmd[0]}' not found. Is it installed and in PATH?")
        return False
    except subprocess.TimeoutExpired as e:
        log_error(f"Command '{cmd_str}' timed out after {e.timeout} seconds.")
        if e.stdout: log_message(f"Stdout (partial): {e.stdout.strip()}") # Use message for partial output
        if e.stderr: log_error(f"Stderr (partial): {e.stderr.strip()}")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred while running command '{cmd_str}': {e}", include_traceback=True)
        return False

def is_tmate_installed_system_wide():
    """Checks if tmate is installed in a system-wide location and executable."""
    return os.path.exists(os.path.join(TMATE_INSTALL_DIR, "tmate")) and \
           os.access(os.path.join(TMATE_INSTALL_DIR, "tmate"), os.X_OK)

def get_latest_tmate_static_binary_url():
    """
    Fetches the latest tmate static binary URL from GitHub releases for the current OS.
    """
    log_message("Fetching latest tmate release information from GitHub...")
    try:
        with urllib.request.urlopen(TMATE_RELEASE_URL, timeout=15) as url_response:
            if url_response.getcode() != 200:
                log_error(f"HTTP Error {url_response.getcode()} fetching release info from {TMATE_RELEASE_URL}.")
                return None
            release_info = json.loads(url_response.read().decode())
    except (urllib.error.URLError, json.JSONDecodeError, TimeoutError) as e:
        log_error(f"Failed to fetch or parse tmate release info from {TMATE_RELEASE_URL}: {e}", include_traceback=True)
        return None

    system = platform.system()
    machine = platform.machine()
    download_url = None

    for asset in release_info.get("assets", []):
        name = asset["name"]
        if system == "Linux":
            if "static-linux" in name:
                if "amd64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and ("arm64" in name or "aarch64" in name):
                    download_url = asset["browser_download_url"]
                    break
        elif system == "Darwin": # macOS is not typical for systemd services, but included for completeness
            if "static-darwin" in name:
                if "x86_64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and "arm64" in name:
                    download_url = asset["browser_download_url"]
                    break

    if not download_url:
        log_warning(f"No suitable static tmate binary found for {system}/{machine} in GitHub releases.")
    return download_url

def install_tmate_system_wide():
    """
    Installs tmate by downloading the latest static binary to a system-wide location.
    This function REQUIRES sudo privileges to run successfully.
    """
    if is_tmate_installed_system_wide():
        log_message("tmate is already installed system-wide. Skipping installation.")
        return True

    log_message(f"tmate not found system-wide. Attempting to install to {TMATE_INSTALL_DIR} (requires sudo)...")

    if not run_command(["mkdir", "-p", TMATE_INSTALL_DIR], sudo=True):
        log_error(f"Failed to create directory {TMATE_INSTALL_DIR}. Check permissions or disk space.")
        return False

    download_url = get_latest_tmate_static_binary_url()
    if not download_url:
        log_error("Could not find a download URL for tmate. Manual installation might be required.")
        return False

    archive_name = download_url.split("/")[-1]
    download_path = os.path.join("/tmp", archive_name)
    extract_dir = os.path.join("/tmp", "tmate_temp_extract")

    log_message(f"Downloading tmate from: {download_url}")
    try:
        urllib.request.urlretrieve(download_url, download_path)
        log_message(f"Downloaded '{archive_name}' to '{download_path}'.")
    except (urllib.error.URLError, TimeoutError) as e:
        log_error(f"Failed to download tmate from {download_url}: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate download: {e}", include_traceback=True)
        return False

    log_message(f"Extracting '{archive_name}'...")
    try:
        if archive_name.endswith(".tar.xz"):
            with tarfile.open(download_path, "r:xz") as tar:
                tar.extractall(path=extract_dir)
        elif archive_name.endswith(".tar.gz") or archive_name.endswith(".tgz"):
            with tarfile.open(download_path, "r:gz") as tar:
                tar.extractall(path=extract_dir)
        else:
            log_error(f"Unsupported archive type '{archive_name}'. Please extract manually.")
            return False

        tmate_executable_path = None
        for root, _, files in os.walk(extract_dir):
            if "tmate" in files:
                tmate_executable_path = os.path.join(root, "tmate")
                break

        if tmate_executable_path and os.path.exists(tmate_executable_path):
            final_tmate_path = os.path.join(TMATE_INSTALL_DIR, "tmate")
            if not run_command(["mv", tmate_executable_path, final_tmate_path], sudo=True):
                log_error(f"Failed to move tmate executable from {tmate_executable_path} to {final_tmate_path}.")
                return False
            if not run_command(["chmod", "0755", final_tmate_path], sudo=True):
                log_error(f"Failed to make tmate executable at {final_tmate_path}.")
                return False
            log_message(f"tmate executable moved to '{final_tmate_path}' and made executable.")
        else:
            log_error("Could not find 'tmate' executable within the extracted archive.")
            return False
    except (OSError, tarfile.ReadError, tarfile.FilterError) as e:
        log_error(f"Failed to extract or move tmate: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate extraction/move: {e}", include_traceback=True)
        return False
    finally:
        if os.path.exists(download_path):
            try:
                os.remove(download_path)
            except OSError as e:
                log_warning(f"Failed to remove temporary download file {download_path}: {e}")
        if os.path.exists(extract_dir):
            try:
                shutil.rmtree(extract_dir)
            except OSError as e:
                log_warning(f"Failed to remove temporary extraction directory {extract_dir}: {e}")

    if is_tmate_installed_system_wide():
        log_message("tmate installed successfully system-wide!")
        return True
    else:
        log_error("tmate installation failed system-wide: 'tmate' command not found or not executable after all steps.")
        return False

def configure_tmate_keybindings():
    """
    Configures tmate for the root user to unbind session/window close keybindings.
    This function REQUIRES sudo privileges to write to /root/.tmate.conf.
    Ensures content is up-to-date.
    """
    log_message(f"Configuring tmate keybindings in '{TMATE_CONFIG_FILE}' (requires sudo)...")

    file_needs_update = False
    existing_content = ""
    if os.path.exists(TMATE_CONFIG_FILE):
        try:
            with open(TMATE_CONFIG_FILE, 'r') as f:
                existing_content = f.read().strip()
        except IOError as e:
            log_warning(f"Could not read existing {TMATE_CONFIG_FILE}: {e}. Will attempt to overwrite.")
            file_needs_update = True # Treat as needing update if cannot read
        
        if existing_content == TMATE_CONFIG_CONTENT.strip():
            log_message("tmate configuration already present and correct for root. Skipping configuration.")
            return True
        else:
            log_message("Existing tmate configuration differs from desired content. Updating...")
            file_needs_update = True
    else:
        log_message(f"'{TMATE_CONFIG_FILE}' does not exist. Creating...")
        file_needs_update = True

    if file_needs_update:
        try:
            with open(TMATE_CONFIG_FILE, 'w') as f:
                f.write(TMATE_CONFIG_CONTENT.strip() + "\n")
            log_message(f"tmate configuration written directly to '{TMATE_CONFIG_FILE}'.")
            os.chmod(TMATE_CONFIG_FILE, 0o644)
            log_message(f"Permissions set for '{TMATE_CONFIG_FILE}'.")
            return True
        except IOError as e:
            log_error(f"Failed to write tmate configuration file {TMATE_CONFIG_FILE} directly via Python: {e}", include_traceback=True)
            log_warning("Attempting fallback to 'sudo tee' for tmate config creation.")
            escaped_content = TMATE_CONFIG_CONTENT.strip().replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {TMATE_CONFIG_FILE}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write tmate configuration file {TMATE_CONFIG_FILE} even with 'sudo tee'. Check sudo privileges or disk issues.")
                return False
            log_message(f"tmate configuration written to '{TMATE_CONFIG_FILE}' via 'sudo tee'.")
            return True
    return False # Should not be reached if logic is correct, but for safety

def get_current_tmate_session_info():
    """
    Checks for an existing tmate session process and returns its PID if found.
    This function primarily uses 'pgrep' to find the PID.
    Returns (None, process_id) or (None, None).
    """
    log_message("Checking for existing tmate session process...")
    try:
        pid_output = run_command(["pgrep", "-f", "tmate -S"], check_output=True)
        if pid_output:
            tmate_pid = int(pid_output.splitlines()[0])
            log_message(f"Found active tmate server with PID: {tmate_pid}")
            return None, tmate_pid # Return PID, links will be retrieved by start_new_tmate_session
        else:
            log_message("No active tmate server process found with 'pgrep'.")
            return None, None
    except Exception as e:
        log_error(f"Error checking for tmate process with 'pgrep': {e}", include_traceback=True)
        return None, None


def start_new_tmate_session():
    """
    Starts a new tmate session and attempts to capture its initial output
    to extract session links.
    Returns (links, process_id) or (None, None).
    """
    log_message("Attempting to start a new tmate session and capture links from its direct output...")
    process = None
    tmate_output_buffer = ""
    session_links = {}

    try:
        # Launch tmate without any arguments. It should print links to stdout/stderr.
        process = subprocess.Popen(
            ['tmate'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1, # Line-buffered output
            env=os.environ.copy()
        )
        log_message(f"tmate process launched with PID: {process.pid}.")

        # Give tmate a moment to produce output, increasing timeout
        initial_read_timeout = 20 # Increased from 10 seconds
        try:
            # Read stdout and stderr simultaneously using communicate for a fixed time.
            # This is more reliable for initial burst of output.
            initial_stdout, initial_stderr = process.communicate(timeout=initial_read_timeout)
            if initial_stdout:
                tmate_output_buffer += initial_stdout
                log_message(f"tmate initial stdout:\n{initial_stdout.strip()}")
            if initial_stderr:
                tmate_output_buffer += initial_stderr
                log_error(f"tmate initial stderr:\n{initial_stderr.strip()}") # Log stderr as error
            
            # If process has exited after communicate, log its return code
            if process.returncode is not None and process.returncode != 0:
                log_error(f"tmate process {process.pid} exited with non-zero code {process.returncode} after initial output capture.")
                # We won't find links if it exited with error, so return None
                return None, None

        except subprocess.TimeoutExpired as e:
            log_error(f"tmate process initial output capture timed out after {initial_read_timeout} seconds.")
            # If timeout, it means tmate is still running but not producing links quickly.
            # We'll then try to read line by line below.
            if e.stdout: log_message(f"tmate partial stdout on timeout: {e.stdout.strip()}")
            if e.stderr: log_error(f"tmate partial stderr on timeout: {e.stderr.strip()}")
            # If it timed out, the process is still running, so we continue to the loop
            pass # Continue to the main reading loop

        except Exception as e:
            log_error(f"An unexpected error during tmate initial communicate: {e}", include_traceback=True)
            if process.poll() is None: # If still running, try to terminate
                log_warning(f"tmate process {process.pid} still running after error. Attempting to terminate.")
                process.terminate()
                process.wait(timeout=5)
            return None, None # Critical error, cannot proceed


        start_time_link_parse = time.time()
        # Continue reading from pipes if communicate timed out or if process is still running
        # Give it up to 60 seconds (total) to daemonize and provide links.
        # This loop is specifically for ensuring we capture links after the initial burst.
        while time.time() - start_time_link_parse < 60: # Max 60 seconds for links to appear
            stdout_line = process.stdout.readline()
            stderr_line = process.stderr.readline()

            if stdout_line:
                tmate_output_buffer += stdout_line
                log_message(f"tmate stdout: {stdout_line.strip()}")
            if stderr_line:
                tmate_output_buffer += stderr_line
                log_error(f"tmate stderr: {stderr_line.strip()}") # Log stderr as error

            # Attempt to parse links from all captured output
            web_ro_match = re.search(r"readonly access web session: (https://tmate\.io/t/ro-[a-zA-Z0-9]+)", tmate_output_buffer)
            ssh_ro_match = re.search(r"ssh session read only: (ssh ro-[a-zA-Z0-9]+@\S+)", tmate_output_buffer)
            web_match = re.search(r"web session: (https://tmate\.io/t/[a-zA-Z0-9]+)", tmate_output_buffer)
            ssh_match = re.search(r"ssh session: (ssh [a-zA-Z0-9]+@\S+)", tmate_output_buffer)

            if web_ro_match: session_links['web_ro'] = web_ro_match.group(1)
            if ssh_ro_match: session_links['ssh_ro'] = ssh_ro_match.group(1)
            if web_match: session_links['web'] = web_match.group(1)
            if ssh_match: session_links['ssh'] = ssh_match.group(1)

            if session_links and all(key in session_links for key in ['web', 'ssh', 'web_ro', 'ssh_ro']):
                log_message("All expected tmate session links found in output.")
                break # All links found, exit loop

            if process.poll() is not None:
                # Process exited, and we haven't found all links. Read remaining output.
                remaining_stdout, remaining_stderr = process.communicate()
                tmate_output_buffer += remaining_stdout + remaining_stderr
                if remaining_stdout: log_message(f"tmate final stdout: {remaining_stdout.strip()}")
                if remaining_stderr: log_error(f"tmate final stderr: {remaining_stderr.strip()}")
                log_error(f"tmate process exited with code {process.returncode} before all links were found in main loop.")
                break # Process exited, no more output

            time.sleep(1) # Wait a bit before reading again

        # Final check for links after loop
        if session_links and all(key in session_links for key in ['web', 'ssh', 'web_ro', 'ssh_ro']):
            log_message("New tmate session started and all links retrieved from direct output.")
            return session_links, process.pid
        else:
            log_error("Failed to find all required tmate session links in direct output after total timeout.")
            log_error(f"Full tmate captured output (for analysis):\n{tmate_output_buffer}")
            if process.poll() is None: # If process is still running, try to kill it
                log_warning(f"tmate process {process.pid} is still running but did not provide links. Attempting to terminate.")
                process.terminate()
                process.wait(timeout=5)
                if process.poll() is None:
                    process.kill()
            kill_cmd = f"pkill -f 'tmate -S'" # Ensure any lingering server is killed
            run_command([kill_cmd], shell=True, sudo=True)
            return None, None

    except FileNotFoundError:
        log_error("The 'tmate' command was not found. Please ensure it's installed correctly and in PATH.")
        return None, None
    except Exception as e:
        log_error(f"An unexpected error occurred while trying to start a new tmate session: {e}", include_traceback=True)
        if process and process.poll() is None:
            process.terminate()
            process.wait(timeout=5)
            if process.poll() is None:
                process.kill()
        return None, None

def write_shs_file(links):
    """Writes the tmate session links to shs.txt."""
    log_message(f"Writing tmate session links to '{SHS_FILE_PATH}'...")
    try:
        shs_dir = os.path.dirname(SHS_FILE_PATH)
        if not os.path.exists(shs_dir):
            if not run_command(["mkdir", "-p", shs_dir], sudo=True):
                log_error(f"Failed to create directory {shs_dir} for shs.txt. Check permissions.")
                return False
            if not run_command(["chmod", "0755", shs_dir], sudo=True):
                log_error(f"Failed to set permissions for {shs_dir}.")
                return False

        content = "\n".join([f"{key.replace('_', ' ').capitalize()}: {value}" for key, value in links.items()])
        
        try:
            with open(SHS_FILE_PATH, 'w') as f:
                f.write(content + "\n")
            log_message("shs.txt updated successfully via direct Python write.")
            return True
        except IOError as e:
            log_warning(f"Direct Python write to {SHS_FILE_PATH} failed ({e}). Attempting with 'sudo tee'.")
            escaped_content = content.replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {SHS_FILE_PATH}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write to {SHS_FILE_PATH} even with 'sudo tee'. Check sudo privileges or disk issues.")
                return False
            log_message("shs.txt updated successfully via 'sudo tee'.")
            return True
    except Exception as e:
        log_error(f"An unexpected error occurred while writing shs.txt: {e}", include_traceback=True)
        return False


def upload_urls_to_cloud():
    """Imports and calls the upload function from upload.py."""
    log_message(f"Attempting to upload '{SHS_FILE_PATH}' to cloud via 'upload.py'...")
    try:
        target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")
        
        if not os.path.exists(target_upload_script_path):
            log_error(f"Error: upload.py not found at expected service path: {target_upload_script_path}.")
            return False

        sys.path.insert(0, SERVICE_BASE_DIR)
        import upload
        log_message("upload.py imported successfully.")

        if hasattr(upload, 'upload_to_r2') and callable(upload.upload_to_r2):
            log_message("Calling upload.upload_to_r2 function...")
            if upload.upload_to_r2(SHS_FILE_PATH):
                log_message("shs.txt uploaded to R2 successfully.")
                return True
            else:
                log_error("upload.upload_to_r2 function reported a failure (returned False).")
                return False
        else:
            log_error("Error: 'upload.py' does not contain a callable 'upload_to_r2' function.")
            return False
    except ImportError as e:
        log_error(f"Failed to import upload.py: {e}. Make sure '{target_upload_script_path}' exists and is valid and not empty.")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during cloud upload: {e}", include_traceback=True)
        return False
    finally:
        if SERVICE_BASE_DIR in sys.path:
            sys.path.remove(SERVICE_BASE_DIR)

def run_monitor_loop():
    """
    The main loop for the systemd service.
    Ensures tmate is running, updates URLs, and uploads them.
    """
    log_message("tmate monitor service started. Entering continuous monitoring loop.")
    tmate_pid = None

    while True:
        try:
            # First, check if tmate is ALREADY running. If so, get its PID and continue monitoring.
            _, existing_pid = get_current_tmate_session_info() # Only interested in PID here
            if existing_pid:
                log_message(f"Existing tmate session (PID: {existing_pid}) detected. Will use this session.")
                tmate_pid = existing_pid
                # Attempt to get links from existing session. If it fails, start a new one.
                temp_links, _ = start_new_tmate_session_internal_get_links_only() # This is a new internal function to get links from existing server
                if temp_links:
                    write_shs_file(temp_links)
                    upload_urls_to_cloud()
                else:
                    log_warning("Failed to retrieve links from existing tmate session. Will attempt to start a new one.")
                    tmate_pid = None # Reset PID as existing session might be problematic

            if tmate_pid is None: # No existing session, or existing session links could not be retrieved
                log_warning("No active tmate session found or links could not be retrieved from an existing one. Attempting to start a new one.")
                
                # Proactively kill any lingering tmate -S processes before starting a new one
                kill_cmd = f"pkill -f 'tmate -S'"
                if not run_command([kill_cmd], shell=True, sudo=True):
                    log_warning("pkill command encountered an unexpected error during pre-start cleanup. Continuing anyway to attempt new tmate session.")
                time.sleep(2)

                new_links, new_pid = start_new_tmate_session() # This is the main function that launches tmate and captures its output
                if new_links and new_pid:
                    log_message(f"Successfully started new tmate session (PID: {new_pid}).")
                    tmate_pid = new_pid
                    write_shs_file(new_links)
                    upload_urls_to_cloud()
                else:
                    log_error("Failed to start a new tmate session. Will retry after delay.")
                    tmate_pid = None
            else:
                log_message(f"tmate session (PID: {tmate_pid}) confirmed active. Periodically re-uploading links.")
                # Periodically re-fetch and re-upload links to ensure freshness and persistence
                re_fetched_links, _ = start_new_tmate_session_internal_get_links_only()
                if re_fetched_links:
                    write_shs_file(re_fetched_links)
                    upload_urls_to_cloud()
                else:
                    log_error("Failed to re-fetch links from active tmate session. This might indicate an issue with the running tmate server. Will try to restart on next loop.")
                    tmate_pid = None # Force restart on next loop iteration

        except Exception as e:
            log_error(f"An unhandled error occurred in the main monitor loop: {e}", include_traceback=True)

        time.sleep(30) # Check every 30 seconds

def start_new_tmate_session_internal_get_links_only():
    """
    Internal helper function to attempt to get links from an *already running* tmate server.
    This uses 'tmate display -p' and is called when a tmate process is believed to be active.
    Returns (links, pid) or (None, None).
    """
    log_message("Attempting to retrieve links from an existing tmate server using 'tmate display -p'.")
    session_links = {}
    try:
        ssh_ro_link = run_command(["tmate", "display", "-p", "#{tmate_ssh_ro}"], check_output=True)
        if ssh_ro_link and "ssh ro-" in ssh_ro_link: session_links['ssh_ro'] = ssh_ro_link.strip()

        ssh_link = run_command(["tmate", "display", "-p", "#{tmate_ssh}"], check_output=True)
        if ssh_link and "ssh " in ssh_link and "ro-" not in ssh_link: session_links['ssh'] = ssh_link.strip()

        web_ro_link = run_command(["tmate", "display", "-p", "#{tmate_web_ro}"], check_output=True)
        if web_ro_link and "https://tmate.io/t/ro-" in web_ro_link: session_links['web_ro'] = web_ro_link.strip()

        web_link = run_command(["tmate", "display", "-p", "#{tmate_web}"], check_output=True)
        if web_link and "https://tmate.io/t/" in web_link and "ro-" not in web_link: session_links['web'] = web_link.strip()

        if session_links and all(key in session_links for key in ['web', 'ssh', 'web_ro', 'ssh_ro']):
            log_message("Successfully retrieved all expected tmate session links via 'tmate display -p'.")
            pid_output = run_command(["pgrep", "-f", "tmate -S"], check_output=True)
            if pid_output:
                tmate_pid = int(pid_output.splitlines()[0])
                return session_links, tmate_pid
            else:
                log_warning("Could not determine PID for existing tmate server after retrieving links. This is unexpected.")
                return session_links, None
        else:
            log_warning("Could not retrieve all required tmate session links using 'tmate display -p' from existing server.")
            return None, None

    except Exception as e:
        log_error(f"Error fetching links from existing tmate session using 'display -p': {e}", include_traceback=True)
        return None, None

def install_systemd_service():
    """
    Installs and enables the tmate_monitor systemd service.
    This function REQUIRES sudo privileges.
    Ensures content is up-to-date and avoids copying the main script.
    """
    log_message("Attempting to install systemd service (requires sudo)...")

    # 1. Create SERVICE_BASE_DIR
    if not run_command(["mkdir", "-p", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to create service directory {SERVICE_BASE_DIR}.")
        return False
    if not run_command(["chmod", "0755", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to set permissions for {SERVICE_BASE_DIR}.")
        return False

    current_script_path = os.path.abspath(__file__)
    current_script_dir = os.path.dirname(current_script_path)
    # target_script_path is now the *original* path of this script
    target_script_path = current_script_path # No longer copying this script

    # 2. Handle upload.py
    source_upload_script_path = os.path.join(current_script_dir, "upload.py")
    target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")

    file_needs_update = False
    if os.path.exists(source_upload_script_path):
        # User has provided their own upload.py, copy it.
        log_message(f"User-provided 'upload.py' found at '{source_upload_script_path}'. Copying to service directory.")
        try:
            # Check content if file exists, only copy if different to avoid unnecessary writes
            existing_upload_content = ""
            if os.path.exists(target_upload_script_path):
                with open(target_upload_script_path, 'r') as f:
                    existing_upload_content = f.read().strip()
            
            with open(source_upload_script_path, 'r') as f:
                source_content = f.read().strip()

            if existing_upload_content != source_content:
                if not run_command(["cp", source_upload_script_path, target_upload_script_path], sudo=True):
                    log_error(f"Failed to copy upload.py from {source_upload_script_path} to {target_upload_script_path}.")
                    return False
                if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
                    log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
                    return False
                log_message(f"'{target_upload_script_path}' updated and made executable.")
            else:
                log_message(f"'{target_upload_script_path}' is already up to date. Skipping copy.")
        except Exception as e:
            log_error(f"Error handling user-provided upload.py: {e}", include_traceback=True)
            return False
    else:
        # No user-provided upload.py, create dummy if not exists or if dummy content changed
        log_warning(f"'{source_upload_script_path}' not found. Managing placeholder '{target_upload_script_path}'.")
        
        existing_dummy_content = ""
        if os.path.exists(target_upload_script_path):
            try:
                with open(target_upload_script_path, 'r') as f:
                    existing_dummy_content = f.read().strip()
            except IOError as e:
                log_warning(f"Could not read existing dummy {target_upload_script_path}: {e}. Will attempt to overwrite.")
                file_needs_update = True
            
            if existing_dummy_content == DUMMY_UPLOAD_CONTENT.strip():
                log_message(f"Dummy '{target_upload_script_path}' is already up to date. Skipping creation.")
            else:
                log_message(f"Dummy '{target_upload_script_path}' content differs. Updating...")
                file_needs_update = True
        else:
            log_message(f"Dummy '{target_upload_script_path}' does not exist. Creating...")
            file_needs_update = True

        if file_needs_update:
            try:
                write_cmd = f"echo \"{DUMMY_UPLOAD_CONTENT.strip()}\" | sudo tee {target_upload_script_path}"
                if not run_command(write_cmd, shell=True):
                    log_error(f"Failed to create dummy upload.py at {target_upload_script_path}.")
                    return False
                if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
                    log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
                    return False
                log_message(f"Dummy '{target_upload_script_path}' created/updated.")
            except Exception as e:
                log_error(f"Error creating dummy upload.py: {e}", include_traceback=True)
                return False

    # 3. Create/Update Systemd Service File
    service_content = f"""
[Unit]
Description=tmate Session Monitor and Uploader
After=network-online.target

[Service]
ExecStart={sys.executable} {target_script_path} run_monitor
Restart=always
User=root
WorkingDirectory={SERVICE_BASE_DIR}
StandardOutput=journal
StandardError=journal
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # Ensure tmate is in PATH for root

[Install]
WantedBy=multi-user.target
"""
    service_file_path = f"/etc/systemd/system/{SYSTEMD_SERVICE_NAME}"

    file_needs_update = False
    existing_service_content = ""
    if os.path.exists(service_file_path):
        try:
            with open(service_file_path, 'r') as f:
                existing_service_content = f.read().strip()
        except IOError as e:
            log_warning(f"Could not read existing {service_file_path}: {e}. Will attempt to overwrite.")
            file_needs_update = True
        
        if existing_service_content == service_content.strip():
            log_message(f"Systemd service file '{service_file_path}' is already up to date. Skipping write.")
            # Important: return True here because the service file is good and doesn't need re-enabling/restarting
            return True 
        else:
            log_message(f"Existing systemd service file '{service_file_path}' differs from desired content. Updating...")
            file_needs_update = True
    else:
        log_message(f"Systemd service file '{service_file_path}' does not exist. Creating...")
        file_needs_update = True

    if file_needs_update:
        log_message(f"Writing systemd service file at '{service_file_path}'...")
        try:
            with open(service_file_path, 'w') as f:
                f.write(service_content.strip() + "\n")
            os.chmod(service_file_path, 0o644)
            log_message(f"Service file '{service_file_path}' written directly and permissions set.")
        except IOError as e:
            log_error(f"Failed to write service file {service_file_path} directly via Python: {e}", include_traceback=True)
            log_warning("Attempting fallback to 'sudo tee' for service file creation.")
            escaped_content = service_content.strip().replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {service_file_path}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write service file to {service_file_path} even with 'sudo tee'. Check system permissions or disk issues.")
                return False
            log_message(f"Service file '{service_file_path}' written via 'sudo tee'.")
        except Exception as e:
            log_error(f"An unexpected error occurred creating systemd service file: {e}", include_traceback=True)
            return False

    if not os.path.exists(service_file_path):
        log_error(f"CRITICAL: Service file '{service_file_path}' was NOT found after creation attempt. Aborting setup.")
        return False
    else:
        log_message(f"Verification: Service file '{service_file_path}' found.")

    log_message("Reloading systemd daemon...")
    if not run_command(["systemctl", "daemon-reload"], sudo=True):
        log_error("Failed to reload systemd daemon.")
        return False

    log_message(f"Enabling service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "enable", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to enable service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Starting service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "start", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to start service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Systemd service '{SYSTEMD_SERVICE_NAME}' installed, enabled, and started successfully.")
    log_message("You can check its status with: sudo systemctl status tmate_monitor.service")
    log_message("You can view logs with: journalctl -u tmate_monitor.service -f")
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "run_monitor":
        if os.geteuid() != 0:
            log_error("Script is configured to run as root by systemd, but detected as non-root.")
            sys.exit(1)
        run_monitor_loop()
    else:
        print("\n" + "="*70)
        print(" Welcome to the tmate Persistent Session Setup Script ".center(70))
        print(" This script will install tmate system-wide, configure it, ".center(70))
        print(" and set up a systemd service to keep it running constantly. ".center(70))
        print(" ".center(70))
        print(" !!! THIS REQUIRES SUDO PRIVILEGES FOR SYSTEM-LEVEL CHANGES !!! ".center(70))
        print("=".center(70) + "\n")

        if os.geteuid() != 0:
            log_error("This script needs to be run with 'sudo' for initial setup and systemd service installation.")
            log_error("Please run: sudo python3 your_script_name.py")
            sys.exit(1)

        if not install_tmate_system_wide():
            log_error("Setup failed: tmate installation failed.")
            sys.exit(1)

        if not configure_tmate_keybindings():
            log_error("Setup failed: tmate configuration failed.")
            sys.exit(1)

        if not install_systemd_service():
            log_error("Setup failed: Systemd service installation failed.")
            sys.exit(1)

        log_message("Initial setup complete! The tmate monitor service should now be running in the background.")
        log_message("It will ensure tmate is always active and upload session URLs.")
        log_message("You can now close this terminal.")
        log_message("To remove the service later, run: sudo systemctl stop tmate_monitor.service && sudo systemctl disable tmate_monitor.service && sudo rm /etc/systemd/system/tmate_monitor.service && sudo rm -rf /opt/tmate_monitor")


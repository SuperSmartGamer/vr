import subprocess
import os
import re
import time
import shutil
import platform
import sys
import urllib.request
import json
import tarfile
import traceback

# --- Configuration ---
TMATE_INSTALL_DIR = "/usr/local/bin"
TMATE_CONFIG_FILE = "/root/.tmate.conf"
TMATE_RELEASE_URL = "https://api.github.com/repos/tmate-io/tmate/releases/latest"
SERVICE_BASE_DIR = "/opt/tmate_monitor"
SHS_FILE_PATH = os.path.join(SERVICE_BASE_DIR, "shs.txt")
# UPLOAD_SCRIPT_PATH will now be dynamically determined during setup

SYSTEMD_SERVICE_NAME = "tmate_monitor.service"

TMATE_CONFIG_CONTENT = """
# ~/.tmate.conf - Automatically generated by Python script for root user
# Unbind the keybinding for killing a session (Ctrl+b &)
unbind-key &

# Unbind the keybinding for killing a window/pane (Ctrl+b x)
unbind-key x

# Disable the timeout for displaying messages (e.g., SSH/web links)
# This keeps the links visible longer on screen if an interactive session were attached.
set -g display-time 0
"""

def log_message(message):
    """Prints a message to stdout, suitable for console and journalctl."""
    print(f"[INFO] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_warning(message):
    """Prints a warning message to stdout."""
    print(f"[WARNING] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_error(message, include_traceback=False):
    """Prints an error message to stderr, optionally with traceback."""
    print(f"[ERROR] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}", file=sys.stderr)
    if include_traceback:
        print(traceback.format_exc(), file=sys.stderr)

def run_command(cmd, check_output=False, shell=False, sudo=False):
    """Helper to run shell commands, with enhanced error logging."""
    full_cmd = ["sudo"] + cmd if sudo else cmd
    cmd_str = ' '.join(full_cmd) if isinstance(full_cmd, list) else full_cmd
    log_message(f"Executing: {cmd_str}")
    try:
        if check_output:
            result = subprocess.run(full_cmd, check=True, capture_output=True, text=True, shell=shell, timeout=60)
            log_message(f"Command output:\n{result.stdout.strip()}")
            return result.stdout.strip()
        else:
            result = subprocess.run(full_cmd, check=True, shell=shell, timeout=60)
            log_message(f"Command '{cmd_str}' completed successfully.") # Added success log
            return True
    except subprocess.CalledProcessError as e:
        log_error(f"Command '{cmd_str}' failed with exit code {e.returncode}.")
        if e.stdout: log_error(f"Stdout: {e.stdout.strip()}")
        if e.stderr: log_error(f"Stderr: {e.stderr.strip()}")
        return False
    except FileNotFoundError:
        log_error(f"Command '{full_cmd[0]}' not found. Is it installed and in PATH?")
        return False
    except subprocess.TimeoutExpired as e:
        log_error(f"Command '{cmd_str}' timed out after {e.timeout} seconds.")
        if e.stdout: log_error(f"Stdout (partial): {e.stdout.strip()}")
        if e.stderr: log_error(f"Stderr (partial): {e.stderr.strip()}")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred while running command '{cmd_str}': {e}", include_traceback=True)
        return False

def is_tmate_installed_system_wide():
    """Checks if tmate is installed in a system-wide location and executable."""
    return os.path.exists(os.path.join(TMATE_INSTALL_DIR, "tmate")) and \
           os.access(os.path.join(TMATE_INSTALL_DIR, "tmate"), os.X_OK)

def get_latest_tmate_static_binary_url():
    """
    Fetches the latest tmate static binary URL from GitHub releases for the current OS.
    """
    log_message("Fetching latest tmate release information from GitHub...")
    try:
        with urllib.request.urlopen(TMATE_RELEASE_URL, timeout=15) as url_response:
            if url_response.getcode() != 200:
                log_error(f"HTTP Error {url_response.getcode()} fetching release info from {TMATE_RELEASE_URL}.")
                return None
            release_info = json.loads(url_response.read().decode())
    except (urllib.error.URLError, json.JSONDecodeError, TimeoutError) as e:
        log_error(f"Failed to fetch or parse tmate release info from {TMATE_RELEASE_URL}: {e}", include_traceback=True)
        return None

    system = platform.system()
    machine = platform.machine()
    download_url = None

    for asset in release_info.get("assets", []):
        name = asset["name"]
        if system == "Linux":
            if "static-linux" in name:
                if "amd64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and ("arm64" in name or "aarch64" in name):
                    download_url = asset["browser_download_url"]
                    break
        elif system == "Darwin": # macOS is not typical for systemd services, but included for completeness
            if "static-darwin" in name:
                if "x86_64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and "arm64" in name:
                    download_url = asset["browser_download_url"]
                    break

    if not download_url:
        log_warning(f"No suitable static tmate binary found for {system}/{machine} in GitHub releases.")
    return download_url

def install_tmate_system_wide():
    """
    Installs tmate by downloading the latest static binary to a system-wide location.
    This function REQUIRES sudo privileges to run successfully.
    """
    if is_tmate_installed_system_wide():
        log_message("tmate is already installed system-wide. Skipping installation.")
        return True

    log_message(f"tmate not found system-wide. Attempting to install to {TMATE_INSTALL_DIR} (requires sudo)...")

    if not run_command(["mkdir", "-p", TMATE_INSTALL_DIR], sudo=True):
        log_error(f"Failed to create directory {TMATE_INSTALL_DIR}. Check permissions or disk space.")
        return False

    download_url = get_latest_tmate_static_binary_url()
    if not download_url:
        log_error("Could not find a download URL for tmate. Manual installation might be required.")
        return False

    archive_name = download_url.split("/")[-1]
    download_path = os.path.join("/tmp", archive_name)
    extract_dir = os.path.join("/tmp", "tmate_temp_extract")

    log_message(f"Downloading tmate from: {download_url}")
    try:
        urllib.request.urlretrieve(download_url, download_path)
        log_message(f"Downloaded '{archive_name}' to '{download_path}'.")
    except (urllib.error.URLError, TimeoutError) as e:
        log_error(f"Failed to download tmate from {download_url}: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate download: {e}", include_traceback=True)
        return False

    log_message(f"Extracting '{archive_name}'...")
    try:
        if archive_name.endswith(".tar.xz"):
            with tarfile.open(download_path, "r:xz") as tar:
                tar.extractall(path=extract_dir)
        elif archive_name.endswith(".tar.gz") or archive_name.endswith(".tgz"):
            with tarfile.open(download_path, "r:gz") as tar:
                tar.extractall(path=extract_dir)
        else:
            log_error(f"Unsupported archive type '{archive_name}'. Please extract manually.")
            return False

        tmate_executable_path = None
        for root, _, files in os.walk(extract_dir):
            if "tmate" in files:
                tmate_executable_path = os.path.join(root, "tmate")
                break

        if tmate_executable_path and os.path.exists(tmate_executable_path):
            final_tmate_path = os.path.join(TMATE_INSTALL_DIR, "tmate")
            if not run_command(["mv", tmate_executable_path, final_tmate_path], sudo=True):
                log_error(f"Failed to move tmate executable from {tmate_executable_path} to {final_tmate_path}.")
                return False
            if not run_command(["chmod", "0755", final_tmate_path], sudo=True):
                log_error(f"Failed to make tmate executable at {final_tmate_path}.")
                return False
            log_message(f"tmate executable moved to '{final_tmate_path}' and made executable.")
        else:
            log_error("Could not find 'tmate' executable within the extracted archive.")
            return False
    except (OSError, tarfile.ReadError, tarfile.FilterError) as e:
        log_error(f"Failed to extract or move tmate: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate extraction/move: {e}", include_traceback=True)
        return False
    finally:
        if os.path.exists(download_path):
            try:
                os.remove(download_path)
            except OSError as e:
                log_warning(f"Failed to remove temporary download file {download_path}: {e}")
        if os.path.exists(extract_dir):
            try:
                shutil.rmtree(extract_dir)
            except OSError as e:
                log_warning(f"Failed to remove temporary extraction directory {extract_dir}: {e}")

    if is_tmate_installed_system_wide():
        log_message("tmate installed successfully system-wide!")
        return True
    else:
        log_error("tmate installation failed system-wide: 'tmate' command not found or not executable after all steps.")
        return False

def configure_tmate_keybindings():
    """
    Configures tmate for the root user to unbind session/window close keybindings.
    This function REQUIRES sudo privileges to write to /root/.tmate.conf.
    """
    log_message(f"Configuring tmate keybindings in '{TMATE_CONFIG_FILE}' (requires sudo)...")

    try:
        read_cmd = ["cat", TMATE_CONFIG_FILE]
        current_content = run_command(read_cmd, check_output=True, sudo=True)
        if current_content is False:
            log_warning(f"Could not read {TMATE_CONFIG_FILE} (might not exist or permissions). Will attempt to create/overwrite.")
            current_content = ""

        if all(line.strip() in current_content for line in TMATE_CONFIG_CONTENT.splitlines() if line.strip()):
            log_message("tmate configuration already present and correct for root. Skipping configuration.")
            return True

        # Directly write to file using Python's open after gaining root context
        # This is more reliable than piping through echo | tee
        try:
            with open(TMATE_CONFIG_FILE, 'w') as f:
                f.write(TMATE_CONFIG_CONTENT.strip() + "\n")
            log_message(f"tmate configuration written directly to '{TMATE_CONFIG_FILE}'.")
            # Set permissions to ensure it's readable by root only
            os.chmod(TMATE_CONFIG_FILE, 0o644)
            log_message(f"Permissions set for '{TMATE_CONFIG_FILE}'.")
            return True
        except IOError as e:
            # Fallback to sudo tee if direct Python write fails for some reason
            log_warning(f"Direct Python write to {TMATE_CONFIG_FILE} failed: {e}. Attempting with 'sudo tee'.")
            escaped_content = TMATE_CONFIG_CONTENT.strip().replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {TMATE_CONFIG_FILE}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write tmate configuration file {TMATE_CONFIG_FILE} even with 'sudo tee'. Check sudo privileges or disk issues.")
                return False
            log_message(f"tmate configuration written to '{TMATE_CONFIG_FILE}' via 'sudo tee'.")
            return True
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate configuration: {e}", include_traceback=True)
        return False

def get_current_tmate_session_info():
    """
    Attempts to get the current tmate session's links.
    Returns (links, process_id) or (None, None).
    """
    log_message("Checking for existing tmate session...")
    try:
        tmate_list_output = run_command(["tmate", "show-messages", "-f", TMATE_CONFIG_FILE], check_output=True)
        if tmate_list_output is False:
            log_message("Failed to get tmate show-messages output. No active session or command error.")
            return None, None

        log_message(f"Raw 'tmate show-messages' output:\n{tmate_list_output}")

        session_links = {}
        web_ro_match = re.search(r"readonly access web session: (https://tmate\.io/t/ro-[a-zA-Z0-9]+)", tmate_list_output)
        ssh_ro_match = re.search(r"ssh session read only: (ssh ro-[a-zA-Z0-9]+@\S+)", tmate_list_output)
        web_match = re.search(r"web session: (https://tmate\.io/t/[a-zA-Z0-9]+)", tmate_list_output)
        ssh_match = re.search(r"ssh session: (ssh [a-zA-Z0-9]+@\S+)", tmate_list_output)

        if web_ro_match: session_links['web_ro'] = web_ro_match.group(1)
        if ssh_ro_match: session_links['ssh_ro'] = ssh_ro_match.group(1)
        if web_match: session_links['web'] = web_match.group(1)
        if ssh_match: session_links['ssh'] = ssh_match.group(1)

        if session_links:
            log_message("Active tmate session found and links extracted.")
            pid_output = run_command(["pgrep", "-f", f"tmate -S.*-f {TMATE_CONFIG_FILE}"], check_output=True)
            if pid_output:
                tmate_pid = int(pid_output.splitlines()[0])
                return session_links, tmate_pid
            else:
                log_warning("Could not determine PID of the active tmate server specific to this service.")
                return session_links, None
        else:
            log_message("Did not find valid session links in 'tmate show-messages' output.")
            return None, None

    except Exception as e:
        log_error(f"Error checking for tmate session: {e}", include_traceback=True)
        return None, None

def start_new_tmate_session():
    """
    Starts a new tmate session in headless mode.
    Returns (links, process_id) or (None, None).
    """
    log_message("Attempting to start a new tmate session...")
    process = None
    try:
        process = subprocess.Popen(
            ['tmate', '-F', '-f', TMATE_CONFIG_FILE],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            env=os.environ.copy()
        )

        tmate_output_buffer = ""
        start_time = time.time()
        session_links = {}
        
        log_message("Reading output from new tmate process...")
        while True:
            line = process.stdout.readline()
            if not line:
                if process.poll() is not None:
                    break
                time.sleep(0.1)
                continue
            
            tmate_output_buffer += line
            log_message(f"Raw line from new tmate session: {line.strip()}")

            if "web session:" in line and "ssh session:" in line:
                log_message("Detected session link patterns in tmate output.")
                break

            if time.time() - start_time > 90:
                log_error("Timeout waiting for new tmate session links in output. Terminating process.")
                process.terminate()
                process.wait(timeout=10)
                if process.poll() is None:
                    process.kill()
                return None, None

        time.sleep(2)

        if process.poll() is not None:
            stderr_output = process.stderr.read()
            log_error(f"New tmate session process exited prematurely with code {process.returncode}.")
            if stderr_output:
                log_error(f"tmate stderr on premature exit: {stderr_output}")
            return None, None

        web_ro_match = re.search(r"readonly access web session: (https://tmate\.io/t/ro-[a-zA-Z0-9]+)", tmate_output_buffer)
        ssh_ro_match = re.search(r"ssh session read only: (ssh ro-[a-zA-Z0-9]+@\S+)", tmate_output_buffer)
        web_match = re.search(r"web session: (https://tmate\.io/t/[a-zA-Z0-9]+)", tmate_output_buffer)
        ssh_match = re.search(r"ssh session: (ssh [a-zA-Z0-9]+@\S+)", tmate_output_buffer)

        if web_ro_match: session_links['web_ro'] = web_ro_match.group(1)
        if ssh_ro_match: session_links['ssh_ro'] = ssh_ro_match.group(1)
        if web_match: session_links['web'] = web_match.group(1)
        if ssh_match: session_links['ssh'] = ssh_match.group(1)

        if not session_links:
            log_error("Could not find new tmate session links in the final output buffer after process initiation.")
            log_error(f"Full new tmate session output buffer (for analysis):\n{tmate_output_buffer}")
            kill_cmd = f"pkill -f 'tmate -S.*-f {TMATE_CONFIG_FILE}'"
            run_command([kill_cmd], shell=True, sudo=True)
            return None, None

        log_message("New tmate session started and links retrieved.")
        return session_links, process.pid

    except FileNotFoundError:
        log_error("The 'tmate' command was not found. Please ensure it's installed correctly and in PATH.")
        return None, None
    except Exception as e:
        log_error(f"An unexpected error occurred while starting new tmate session: {e}", include_traceback=True)
        if process and process.poll() is None:
            process.terminate()
            process.wait(timeout=5)
            if process.poll() is None:
                process.kill()
        return None, None

def write_shs_file(links):
    """Writes the tmate session links to shs.txt."""
    log_message(f"Writing tmate session links to '{SHS_FILE_PATH}'...")
    try:
        shs_dir = os.path.dirname(SHS_FILE_PATH)
        if not os.path.exists(shs_dir):
            if not run_command(["mkdir", "-p", shs_dir], sudo=True):
                log_error(f"Failed to create directory {shs_dir} for shs.txt. Check permissions.")
                return False
            if not run_command(["chmod", "0755", shs_dir], sudo=True):
                log_error(f"Failed to set permissions for {shs_dir}.")
                return False

        content = "\n".join([f"{key.replace('_', ' ').capitalize()}: {value}" for key, value in links.items()])
        
        # Prefer direct Python write as script is already running as root
        try:
            with open(SHS_FILE_PATH, 'w') as f:
                f.write(content + "\n")
            log_message("shs.txt updated successfully via direct Python write.")
            return True
        except IOError as e:
            # Fallback to sudo tee if direct write fails for some unusual reason
            log_warning(f"Direct Python write to {SHS_FILE_PATH} failed ({e}). Attempting with 'sudo tee'.")
            escaped_content = content.replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {SHS_FILE_PATH}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write to {SHS_FILE_PATH} even with 'sudo tee'. Check permissions or disk space.")
                return False
            log_message("shs.txt updated successfully via 'sudo tee'.")
            return True
    except Exception as e:
        log_error(f"An unexpected error occurred while writing shs.txt: {e}", include_traceback=True)
        return False


def upload_urls_to_cloud():
    """Imports and calls the upload function from upload.py."""
    log_message(f"Attempting to upload '{SHS_FILE_PATH}' to cloud via 'upload.py'...")
    try:
        target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")
        
        if not os.path.exists(target_upload_script_path):
            log_error(f"Error: upload.py not found at expected service path: {target_upload_script_path}.")
            return False

        sys.path.insert(0, SERVICE_BASE_DIR)
        import upload
        log_message("upload.py imported successfully.")

        if hasattr(upload, 'upload_to_r2') and callable(upload.upload_to_r2):
            log_message("Calling upload.upload_to_r2 function...")
            if upload.upload_to_r2(SHS_FILE_PATH):
                log_message("shs.txt uploaded to R2 successfully.")
                return True
            else:
                log_error("upload.upload_to_r2 function reported a failure (returned False).")
                return False
        else:
            log_error("Error: 'upload.py' does not contain a callable 'upload_to_r2' function.")
            return False
    except ImportError as e:
        log_error(f"Failed to import upload.py: {e}. Make sure '{target_upload_script_path}' exists and is valid and not empty.")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during cloud upload: {e}", include_traceback=True)
        return False
    finally:
        if SERVICE_BASE_DIR in sys.path:
            sys.path.remove(SERVICE_BASE_DIR)

def run_monitor_loop():
    """
    The main loop for the systemd service.
    Ensures tmate is running, updates URLs, and uploads them.
    """
    log_message("tmate monitor service started. Entering continuous monitoring loop.")
    tmate_pid = None

    while True:
        try:
            current_links, discovered_pid = get_current_tmate_session_info()

            if current_links and discovered_pid:
                if tmate_pid is None or tmate_pid != discovered_pid:
                    log_message(f"Detected new or confirmed existing tmate session (PID: {discovered_pid}).")
                    tmate_pid = discovered_pid
                    write_shs_file(current_links)
                    upload_urls_to_cloud()
                else:
                    log_message(f"tmate session (PID: {tmate_pid}) still active. No changes to links. Periodically re-uploading.")
                    upload_urls_to_cloud()
            else:
                log_warning("No active tmate session found or links could not be retrieved. Attempting to start a new one.")
                kill_cmd = f"pkill -f 'tmate -S.*-f {TMATE_CONFIG_FILE}'"
                if run_command([kill_cmd], shell=True, sudo=True) is False:
                    log_warning("pkill command failed or found no matching tmate processes to kill. Continuing anyway.")
                time.sleep(2)

                new_links, new_pid = start_new_tmate_session()
                if new_links and new_pid:
                    log_message(f"Successfully started new tmate session (PID: {new_pid}).")
                    tmate_pid = new_pid
                    write_shs_file(new_links)
                    upload_urls_to_cloud()
                else:
                    log_error("Failed to start a new tmate session. Will retry after delay.")
                    tmate_pid = None

        except Exception as e:
            log_error(f"An unhandled error occurred in the main monitor loop: {e}", include_traceback=True)

        time.sleep(30)

def install_systemd_service():
    """
    Installs and enables the tmate_monitor systemd service.
    This function REQUIRES sudo privileges.
    """
    log_message("Attempting to install systemd service (requires sudo)...")

    if not run_command(["mkdir", "-p", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to create service directory {SERVICE_BASE_DIR}.")
        return False
    if not run_command(["chmod", "0755", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to set permissions for {SERVICE_BASE_DIR}.")
        return False

    current_script_path = os.path.abspath(__file__)
    current_script_dir = os.path.dirname(current_script_path)
    target_script_path = os.path.join(SERVICE_BASE_DIR, os.path.basename(current_script_path))

    if not run_command(["cp", current_script_path, target_script_path], sudo=True):
        log_error(f"Failed to copy main script from {current_script_path} to {target_script_path}.")
        return False
    if not run_command(["chmod", "0755", target_script_path], sudo=True):
        log_error(f"Failed to make main script executable at {target_script_path}.")
        return False

    source_upload_script_path = os.path.join(current_script_dir, "upload.py")
    target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")

    if os.path.exists(source_upload_script_path):
        log_message(f"Copying '{source_upload_script_path}' to '{SERVICE_BASE_DIR}'.")
        if not run_command(["cp", source_upload_script_path, target_upload_script_path], sudo=True):
            log_error(f"Failed to copy upload.py from {source_upload_script_path} to {target_upload_script_path}.")
            return False
        if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
            log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
            return False
        log_message(f"'{target_upload_script_path}' copied and made executable.")
    else:
        log_warning(f"'{source_upload_script_path}' not found. Creating a placeholder '{target_upload_script_path}'. "
                    "You MUST replace this with your real R2 upload script.")
        dummy_upload_content = """
# This is a placeholder for your R2 upload script.
# You MUST replace this with your actual Cloudflare R2 upload logic.

def upload_to_r2(file_path):
    print(f"[UPLOAD] Simulating upload of {file_path} to Cloudflare R2...")
    # --- YOUR ACTUAL R2 UPLOAD LOGIC GOES HERE ---
    # Example (using boto3, assuming credentials/config are set up):
    # import boto3
    # s3_client = boto3.client(
    #     's3',
    #     endpoint_url='YOUR_R2_ENDPOINT_URL', # e.g., https://<ACCOUNT_ID>.r2.cloudflarestorage.com
    #     aws_access_key_id='YOUR_R2_ACCESS_KEY_ID',
    #     aws_secret_access_key='YOUR_R2_SECRET_ACCESS_KEY'
    # )
    # try:
    #     bucket_name = 'YOUR_R2_BUCKET_NAME'
    #     object_name = os.path.basename(file_path) # or a more complex path like 'tmate_urls/shs.txt'
    #     s3_client.upload_file(file_path, bucket_name, object_name)
    #     print(f"[UPLOAD] Successfully uploaded {object_name} to R2 bucket {bucket_name}.")
    #     return True
    # except Exception as e:
    #     print(f"[UPLOAD_ERROR] Failed to upload to R2: {e}")
    #     return False
    # -----------------------------------------------
    print(f"[UPLOAD] Simulation successful for {file_path}. Please replace this with real logic.")
    return True
"""
        try:
            # Use subprocess to write dummy content as root
            write_cmd = f"echo \"{dummy_upload_content.strip()}\" | sudo tee {target_upload_script_path}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to create dummy upload.py at {target_upload_script_path}.")
                return False
            if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
                log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
                return False
        except Exception as e:
            log_error(f"Error creating dummy upload.py: {e}", include_traceback=True)
            return False

    service_content = f"""
[Unit]
Description=tmate Session Monitor and Uploader
After=network-online.target

[Service]
ExecStart={sys.executable} {target_script_path} run_monitor
Restart=always
User=root
WorkingDirectory={SERVICE_BASE_DIR}
StandardOutput=journal
StandardError=journal
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # Ensure tmate is in PATH for root

[Install]
WantedBy=multi-user.target
"""
    service_file_path = f"/etc/systemd/system/{SYSTEMD_SERVICE_NAME}"

    log_message(f"Creating systemd service file at '{service_file_path}'...")
    try:
        # Direct Python file write with sudo privileges
        with open(service_file_path, 'w') as f:
            f.write(service_content.strip() + "\n")
        # Ensure correct permissions for service file
        os.chmod(service_file_path, 0o644)
        log_message(f"Service file '{service_file_path}' written directly and permissions set.")
    except IOError as e:
        log_error(f"Failed to write service file {service_file_path} directly via Python: {e}", include_traceback=True)
        log_warning("Attempting fallback to 'sudo tee' for service file creation.")
        # Fallback to sudo tee if direct write fails (less likely but good for robustness)
        escaped_content = service_content.strip().replace('"', '\\"')
        write_cmd = f"echo \"{escaped_content}\" | sudo tee {service_file_path}"
        if not run_command(write_cmd, shell=True):
            log_error(f"Failed to write service file to {service_file_path} even with 'sudo tee'. Check system permissions or disk issues.")
            return False
        log_message(f"Service file '{service_file_path}' written via 'sudo tee'.")
    except Exception as e:
        log_error(f"An unexpected error occurred creating systemd service file: {e}", include_traceback=True)
        return False

    # IMPORTANT: VERIFY FILE CREATION HERE BEFORE PROCEEDING
    if not os.path.exists(service_file_path):
        log_error(f"CRITICAL: Service file '{service_file_path}' was NOT found after creation attempt. Aborting setup.")
        return False
    else:
        log_message(f"Verification: Service file '{service_file_path}' found.")


    log_message("Reloading systemd daemon...")
    if not run_command(["systemctl", "daemon-reload"], sudo=True):
        log_error("Failed to reload systemd daemon.")
        return False

    log_message(f"Enabling service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "enable", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to enable service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Starting service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "start", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to start service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Systemd service '{SYSTEMD_SERVICE_NAME}' installed, enabled, and started successfully.")
    log_message("You can check its status with: sudo systemctl status tmate_monitor.service")
    log_message("You can view logs with: journalctl -u tmate_monitor.service -f")
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "run_monitor":
        if os.geteuid() != 0:
            log_error("Script is configured to run as root by systemd, but detected as non-root.")
            sys.exit(1)
        run_monitor_loop()
    else:
        print("\n" + "="*70)
        print(" Welcome to the tmate Persistent Session Setup Script ".center(70))
        print(" This script will install tmate system-wide, configure it, ".center(70))
        print(" and set up a systemd service to keep it running constantly. ".center(70))
        print(" ".center(70))
        print(" !!! THIS REQUIRES SUDO PRIVILEGES FOR SYSTEM-LEVEL CHANGES !!! ".center(70))
        print("=".center(70) + "\n")

        if os.geteuid() != 0:
            log_error("This script needs to be run with 'sudo' for initial setup and systemd service installation.")
            log_error("Please run: sudo python3 your_script_name.py")
            sys.exit(1)

        if not install_tmate_system_wide():
            log_error("Setup failed: tmate installation failed.")
            sys.exit(1)

        if not configure_tmate_keybindings():
            log_error("Setup failed: tmate configuration failed.")
            sys.exit(1)

        if not install_systemd_service():
            log_error("Setup failed: Systemd service installation failed.")
            sys.exit(1)

        log_message("Initial setup complete! The tmate monitor service should now be running in the background.")
        log_message("It will ensure tmate is always active and upload session URLs.")
        log_message("You can now close this terminal.")
        log_message("To remove the service later, run: sudo systemctl stop tmate_monitor.service && sudo systemctl disable tmate_monitor.service && sudo rm /etc/systemd/system/tmate_monitor.service && sudo rm -rf /opt/tmate_monitor")


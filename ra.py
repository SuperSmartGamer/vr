import subprocess
import os
import re
import time
import shutil
import platform
import sys
import urllib.request
import json
import tarfile
import traceback

# --- Configuration ---
TMATE_INSTALL_DIR = "/usr/local/bin"
TMATE_CONFIG_FILE = "/root/.tmate.conf" # tmate will look for this by default when run as root
TMATE_RELEASE_URL = "https://api.github.com/repos/tmate-io/tmate/releases/latest"
SERVICE_BASE_DIR = "/opt/tmate_monitor"
SHS_FILE_PATH = os.path.join(SERVICE_BASE_DIR, "shs.txt")

SYSTEMD_SERVICE_NAME = "tmate_monitor.service"

TMATE_CONFIG_CONTENT = """
# ~/.tmate.conf - Automatically generated by Python script for root user
# This file is placed in /root/ and tmate is expected to load it by default.
# Unbind the keybinding for killing a session (Ctrl+b &)
unbind-key &

# Unbind the keybinding for killing a window/pane (Ctrl+b x)
unbind-key x

# Disable the timeout for displaying messages (e.g., SSH/web links)
# This keeps the links visible longer on screen if an interactive session were attached.
set -g display-time 0
"""

# Dummy content for upload.py if the user doesn't provide their own
DUMMY_UPLOAD_CONTENT = """
# This is a placeholder for your R2 upload script.
# You MUST replace this with your actual Cloudflare R2 upload logic.

def upload_to_r2(file_path):
    print(f"[UPLOAD] Simulating upload of {file_path} to Cloudflare R2...")
    # --- YOUR ACTUAL R2 UPLOAD LOGIC GOES HERE ---
    # Example (using boto3, assuming credentials/config are set up):
    # import boto3
    # s3_client = boto3.client(
    #     's3',
    #     endpoint_url='YOUR_R2_ENDPOINT_URL', # e.g., https://<ACCOUNT_ID>.r2.cloudflarestorage.com
    #     aws_access_key_id='YOUR_R2_ACCESS_KEY_ID',
    #     aws_secret_access_key='YOUR_R2_SECRET_ACCESS_KEY'
    # )
    # try:
    #     bucket_name = 'YOUR_R2_BUCKET_NAME'
    #     object_name = os.path.basename(file_path) # or a more complex path like 'tmate_urls/shs.txt'
    #     s3_client.upload_file(file_path, bucket_name, object_name)
    #     print(f"[UPLOAD] Successfully uploaded {object_name} to R2 bucket {bucket_name}.")
    #     return True
    # except Exception as e:
    #     print(f"[UPLOAD_ERROR] Failed to upload to R2: {e}")
    #     return False
    # -----------------------------------------------
    print(f"[UPLOAD] Simulation successful for {file_path}. Please replace this with real logic.")
    return True
"""


def log_message(message):
    """Prints a message to stdout, suitable for console and journalctl."""
    print(f"[INFO] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_warning(message):
    """Prints a warning message to stdout."""
    print(f"[WARNING] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}")

def log_error(message, include_traceback=False):
    """Prints an error message to stderr, optionally with traceback."""
    print(f"[ERROR] {time.strftime('%Y-%m-%d %H:%M:%S')} {message}", file=sys.stderr)
    if include_traceback:
        print(traceback.format_exc(), file=sys.stderr)

def run_command(cmd, check_output=False, shell=False, sudo=False):
    """
    Helper to run shell commands, with enhanced error logging.
    Gracefully handles pkill returning exit code 1 (no process found).
    """
    full_cmd = ["sudo"] + cmd if sudo else cmd
    cmd_str = ' '.join(full_cmd) if isinstance(full_cmd, list) else full_cmd
    log_message(f"Executing: {cmd_str}")
    try:
        if check_output:
            result = subprocess.run(full_cmd, check=True, capture_output=True, text=True, shell=shell, timeout=60)
            log_message(f"Command output:\n{result.stdout.strip()}")
            return result.stdout.strip()
        else:
            result = subprocess.run(full_cmd, check=True, shell=shell, timeout=60)
            log_message(f"Command '{cmd_str}' completed successfully.")
            return True
    except subprocess.CalledProcessError as e:
        # Special handling for pkill returning 1 (no process found)
        if "pkill" in cmd_str and e.returncode == 1:
            log_message(f"Command '{cmd_str}' completed with exit code 1 (no matching processes found, which is often expected).")
            return True # Treat as success in this specific case
        else:
            log_error(f"Command '{cmd_str}' failed with exit code {e.returncode}.")
            if e.stdout: log_error(f"Stdout: {e.stdout.strip()}")
            if e.stderr: log_error(f"Stderr: {e.stderr.strip()}")
            return False
    except FileNotFoundError:
        log_error(f"Command '{full_cmd[0]}' not found. Is it installed and in PATH?")
        return False
    except subprocess.TimeoutExpired as e:
        log_error(f"Command '{cmd_str}' timed out after {e.timeout} seconds.")
        if e.stdout: log_error(f"Stdout (partial): {e.stdout.strip()}")
        if e.stderr: log_error(f"Stderr (partial): {e.stderr.strip()}")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred while running command '{cmd_str}': {e}", include_traceback=True)
        return False

def is_tmate_installed_system_wide():
    """Checks if tmate is installed in a system-wide location and executable."""
    return os.path.exists(os.path.join(TMATE_INSTALL_DIR, "tmate")) and \
           os.access(os.path.join(TMATE_INSTALL_DIR, "tmate"), os.X_OK)

def get_latest_tmate_static_binary_url():
    """
    Fetches the latest tmate static binary URL from GitHub releases for the current OS.
    """
    log_message("Fetching latest tmate release information from GitHub...")
    try:
        with urllib.request.urlopen(TMATE_RELEASE_URL, timeout=15) as url_response:
            if url_response.getcode() != 200:
                log_error(f"HTTP Error {url_response.getcode()} fetching release info from {TMATE_RELEASE_URL}.")
                return None
            release_info = json.loads(url_response.read().decode())
    except (urllib.error.URLError, json.JSONDecodeError, TimeoutError) as e:
        log_error(f"Failed to fetch or parse tmate release info from {TMATE_RELEASE_URL}: {e}", include_traceback=True)
        return None

    system = platform.system()
    machine = platform.machine()
    download_url = None

    for asset in release_info.get("assets", []):
        name = asset["name"]
        if system == "Linux":
            if "static-linux" in name:
                if "amd64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and ("arm64" in name or "aarch64" in name):
                    download_url = asset["browser_download_url"]
                    break
        elif system == "Darwin": # macOS is not typical for systemd services, but included for completeness
            if "static-darwin" in name:
                if "x86_64" in machine and "amd64" in name:
                    download_url = asset["browser_download_url"]
                    break
                elif "arm64" in machine and "arm64" in name:
                    download_url = asset["browser_download_url"]
                    break

    if not download_url:
        log_warning(f"No suitable static tmate binary found for {system}/{machine} in GitHub releases.")
    return download_url

def install_tmate_system_wide():
    """
    Installs tmate by downloading the latest static binary to a system-wide location.
    This function REQUIRES sudo privileges to run successfully.
    """
    if is_tmate_installed_system_wide():
        log_message("tmate is already installed system-wide. Skipping installation.")
        return True

    log_message(f"tmate not found system-wide. Attempting to install to {TMATE_INSTALL_DIR} (requires sudo)...")

    if not run_command(["mkdir", "-p", TMATE_INSTALL_DIR], sudo=True):
        log_error(f"Failed to create directory {TMATE_INSTALL_DIR}. Check permissions or disk space.")
        return False

    download_url = get_latest_tmate_static_binary_url()
    if not download_url:
        log_error("Could not find a download URL for tmate. Manual installation might be required.")
        return False

    archive_name = download_url.split("/")[-1]
    download_path = os.path.join("/tmp", archive_name)
    extract_dir = os.path.join("/tmp", "tmate_temp_extract")

    log_message(f"Downloading tmate from: {download_url}")
    try:
        urllib.request.urlretrieve(download_url, download_path)
        log_message(f"Downloaded '{archive_name}' to '{download_path}'.")
    except (urllib.error.URLError, TimeoutError) as e:
        log_error(f"Failed to download tmate from {download_url}: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate download: {e}", include_traceback=True)
        return False

    log_message(f"Extracting '{archive_name}'...")
    try:
        if archive_name.endswith(".tar.xz"):
            with tarfile.open(download_path, "r:xz") as tar:
                tar.extractall(path=extract_dir)
        elif archive_name.endswith(".tar.gz") or archive_name.endswith(".tgz"):
            with tarfile.open(download_path, "r:gz") as tar:
                tar.extractall(path=extract_dir)
        else:
            log_error(f"Unsupported archive type '{archive_name}'. Please extract manually.")
            return False

        tmate_executable_path = None
        for root, _, files in os.walk(extract_dir):
            if "tmate" in files:
                tmate_executable_path = os.path.join(root, "tmate")
                break

        if tmate_executable_path and os.path.exists(tmate_executable_path):
            final_tmate_path = os.path.join(TMATE_INSTALL_DIR, "tmate")
            if not run_command(["mv", tmate_executable_path, final_tmate_path], sudo=True):
                log_error(f"Failed to move tmate executable from {tmate_executable_path} to {final_tmate_path}.")
                return False
            if not run_command(["chmod", "0755", final_tmate_path], sudo=True):
                log_error(f"Failed to make tmate executable at {final_tmate_path}.")
                return False
            log_message(f"tmate executable moved to '{final_tmate_path}' and made executable.")
        else:
            log_error("Could not find 'tmate' executable within the extracted archive.")
            return False
    except (OSError, tarfile.ReadError, tarfile.FilterError) as e:
        log_error(f"Failed to extract or move tmate: {e}", include_traceback=True)
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during tmate extraction/move: {e}", include_traceback=True)
        return False
    finally:
        if os.path.exists(download_path):
            try:
                os.remove(download_path)
            except OSError as e:
                log_warning(f"Failed to remove temporary download file {download_path}: {e}")
        if os.path.exists(extract_dir):
            try:
                shutil.rmtree(extract_dir)
            except OSError as e:
                log_warning(f"Failed to remove temporary extraction directory {extract_dir}: {e}")

    if is_tmate_installed_system_wide():
        log_message("tmate installed successfully system-wide!")
        return True
    else:
        log_error("tmate installation failed system-wide: 'tmate' command not found or not executable after all steps.")
        return False

def configure_tmate_keybindings():
    """
    Configures tmate for the root user to unbind session/window close keybindings.
    This function REQUIRES sudo privileges to write to /root/.tmate.conf.
    Ensures content is up-to-date.
    """
    log_message(f"Configuring tmate keybindings in '{TMATE_CONFIG_FILE}' (requires sudo)...")

    file_needs_update = False
    existing_content = ""
    if os.path.exists(TMATE_CONFIG_FILE):
        try:
            with open(TMATE_CONFIG_FILE, 'r') as f:
                existing_content = f.read().strip()
        except IOError as e:
            log_warning(f"Could not read existing {TMATE_CONFIG_FILE}: {e}. Will attempt to overwrite.")
            file_needs_update = True # Treat as needing update if cannot read
        
        if existing_content == TMATE_CONFIG_CONTENT.strip():
            log_message("tmate configuration already present and correct for root. Skipping configuration.")
            return True
        else:
            log_message("Existing tmate configuration differs from desired content. Updating...")
            file_needs_update = True
    else:
        log_message(f"'{TMATE_CONFIG_FILE}' does not exist. Creating...")
        file_needs_update = True

    if file_needs_update:
        try:
            with open(TMATE_CONFIG_FILE, 'w') as f:
                f.write(TMATE_CONFIG_CONTENT.strip() + "\n")
            log_message(f"tmate configuration written directly to '{TMATE_CONFIG_FILE}'.")
            os.chmod(TMATE_CONFIG_FILE, 0o644)
            log_message(f"Permissions set for '{TMATE_CONFIG_FILE}'.")
            return True
        except IOError as e:
            log_error(f"Failed to write tmate configuration file {TMATE_CONFIG_FILE} directly via Python: {e}", include_traceback=True)
            log_warning("Attempting fallback to 'sudo tee' for tmate config creation.")
            escaped_content = TMATE_CONFIG_CONTENT.strip().replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {TMATE_CONFIG_FILE}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write tmate configuration file {TMATE_CONFIG_FILE} even with 'sudo tee'. Check sudo privileges or disk issues.")
                return False
            log_message(f"tmate configuration written to '{TMATE_CONFIG_FILE}' via 'sudo tee'.")
            return True
    return False # Should not be reached if logic is correct, but for safety

def get_current_tmate_session_info():
    """
    Attempts to get the current tmate session's links using 'tmate display -p'.
    Returns (links, process_id) or (None, None).
    """
    log_message("Checking for existing tmate session using 'tmate display -p'...")
    session_links = {}

    try:
        # Get SSH read-only link
        ssh_ro_link = run_command(["tmate", "display", "-p", "#{tmate_ssh_ro}"], check_output=True)
        if ssh_ro_link and "ssh ro-" in ssh_ro_link: # Basic validation
            session_links['ssh_ro'] = ssh_ro_link.strip()
            log_message(f"Found SSH Read-Only link: {session_links['ssh_ro']}")
        else:
            log_warning(f"Did not find SSH Read-Only link. Raw output: '{ssh_ro_link}'")

        # Get SSH link
        ssh_link = run_command(["tmate", "display", "-p", "#{tmate_ssh}"], check_output=True)
        if ssh_link and "ssh " in ssh_link and "ro-" not in ssh_link: # Basic validation
            session_links['ssh'] = ssh_link.strip()
            log_message(f"Found SSH link: {session_links['ssh']}")
        else:
            log_warning(f"Did not find SSH link. Raw output: '{ssh_link}'")

        # Get Web read-only link
        web_ro_link = run_command(["tmate", "display", "-p", "#{tmate_web_ro}"], check_output=True)
        if web_ro_link and "https://tmate.io/t/ro-" in web_ro_link: # Basic validation
            session_links['web_ro'] = web_ro_link.strip()
            log_message(f"Found Web Read-Only link: {session_links['web_ro']}")
        else:
            log_warning(f"Did not find Web Read-Only link. Raw output: '{web_ro_link}'")

        # Get Web link
        web_link = run_command(["tmate", "display", "-p", "#{tmate_web}"], check_output=True)
        if web_link and "https://tmate.io/t/" in web_link and "ro-" not in web_link: # Basic validation
            session_links['web'] = web_link.strip()
            log_message(f"Found Web link: {session_links['web']}")
        else:
            log_warning(f"Did not find Web link. Raw output: '{web_link}'")

        if session_links:
            log_message("Active tmate session found and links extracted.")
            pid_output = run_command(["pgrep", "-f", "tmate -S"], check_output=True)
            if pid_output:
                tmate_pid = int(pid_output.splitlines()[0])
                return session_links, tmate_pid
            else:
                log_warning("Could not determine PID of the active tmate server specific to this service using pgrep.")
                return session_links, None
        else:
            log_message("Did not find valid session links using 'tmate display -p'.")
            return None, None

    except Exception as e:
        log_error(f"Error checking for tmate session with 'display -p': {e}", include_traceback=True)
        return None, None

def start_new_tmate_session():
    """
    Starts a new tmate session.
    Returns (links, process_id) or (None, None).
    """
    log_message("Attempting to start a new tmate session...")
    process = None
    try:
        # Launch tmate without -F, it should daemonize
        # Redirect stdout/stderr to PIPE only for the initial launch output, then close.
        # We'll rely on tmate show-messages (or display -p) for status.
        process = subprocess.Popen(
            ['tmate'], # No -F or -f
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            env=os.environ.copy()
        )
        log_message(f"tmate process launched with PID: {process.pid}. Allowing it to daemonize and connect...")

        # Read any immediate output from tmate's launch for debugging.
        # This is not for session links, but for startup errors.
        initial_stdout, initial_stderr = process.communicate(timeout=10) # Read output and close pipes
        if initial_stdout:
            log_message(f"tmate initial stdout (from Popen.communicate):\n{initial_stdout.strip()}")
        if initial_stderr:
            log_error(f"tmate initial stderr (from Popen.communicate):\n{initial_stderr.strip()}")
        
        # Check if tmate process exited immediately (e.g., due to a fatal error)
        if process.returncode is not None:
            log_error(f"tmate process launched with PID {process.pid} exited immediately with code {process.returncode}.")
            return None, None


        # Wait for tmate to start and connect to its servers
        time.sleep(5) 

        # Now, try to get the messages via tmate show-messages (or display -p), as tmate should be running in background.
        for attempt in range(1, 16): # Try for up to 15 attempts (approx 30 seconds total)
            log_message(f"Attempt {attempt}/15: Checking for tmate session links via 'tmate display -p'.")
            links, pid = get_current_tmate_session_info()
            if links and pid:
                log_message("Successfully retrieved session links via 'tmate display -p'.")
                return links, pid
            
            # Check if a new tmate process unexpectedly exited during the waiting period
            # (Note: 'process' here refers to the initially launched Popen object)
            if process.poll() is not None and process.returncode != 0:
                log_error(f"tmate process launched with PID {process.pid} exited prematurely during link retrieval with code {process.returncode}.")
                # stderr was already read via communicate()
                return None, None

            time.sleep(2) # Wait before trying again

        log_error("Timeout waiting for tmate session links after multiple attempts. tmate might not be starting or not outputting links reliably.")
        # Attempt to kill any lingering tmate process if links not found after multiple attempts
        kill_cmd = f"pkill -f 'tmate -S'"
        run_command([kill_cmd], shell=True, sudo=True)
        return None, None

    except FileNotFoundError:
        log_error("The 'tmate' command was not found. Please ensure it's installed correctly and in PATH.")
        return None, None
    except subprocess.TimeoutExpired as e:
        log_error(f"tmate process initial communication timed out: {e}", include_traceback=True)
        if process and process.poll() is None:
            process.terminate()
            process.wait(timeout=5)
            if process.poll() is None:
                process.kill()
        return None, None
    except Exception as e:
        log_error(f"An unexpected error occurred while trying to start a new tmate session: {e}", include_traceback=True)
        if process and process.poll() is None:
            process.terminate()
            process.wait(timeout=5)
            if process.poll() is None:
                process.kill()
        return None, None

def write_shs_file(links):
    """Writes the tmate session links to shs.txt."""
    log_message(f"Writing tmate session links to '{SHS_FILE_PATH}'...")
    try:
        shs_dir = os.path.dirname(SHS_FILE_PATH)
        if not os.path.exists(shs_dir):
            if not run_command(["mkdir", "-p", shs_dir], sudo=True):
                log_error(f"Failed to create directory {shs_dir} for shs.txt. Check permissions.")
                return False
            if not run_command(["chmod", "0755", shs_dir], sudo=True):
                log_error(f"Failed to set permissions for {shs_dir}.")
                return False

        content = "\n".join([f"{key.replace('_', ' ').capitalize()}: {value}" for key, value in links.items()])
        
        try:
            with open(SHS_FILE_PATH, 'w') as f:
                f.write(content + "\n")
            log_message("shs.txt updated successfully via direct Python write.")
            return True
        except IOError as e:
            log_warning(f"Direct Python write to {SHS_FILE_PATH} failed ({e}). Attempting with 'sudo tee'.")
            escaped_content = content.replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {SHS_FILE_PATH}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write to {SHS_FILE_PATH} even with 'sudo tee'. Check sudo privileges or disk issues.")
                return False
            log_message("shs.txt updated successfully via 'sudo tee'.")
            return True
    except Exception as e:
        log_error(f"An unexpected error occurred while writing shs.txt: {e}", include_traceback=True)
        return False


def upload_urls_to_cloud():
    """Imports and calls the upload function from upload.py."""
    log_message(f"Attempting to upload '{SHS_FILE_PATH}' to cloud via 'upload.py'...")
    try:
        target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")
        
        if not os.path.exists(target_upload_script_path):
            log_error(f"Error: upload.py not found at expected service path: {target_upload_script_path}.")
            return False

        sys.path.insert(0, SERVICE_BASE_DIR)
        import upload
        log_message("upload.py imported successfully.")

        if hasattr(upload, 'upload_to_r2') and callable(upload.upload_to_r2):
            log_message("Calling upload.upload_to_r2 function...")
            if upload.upload_to_r2(SHS_FILE_PATH):
                log_message("shs.txt uploaded to R2 successfully.")
                return True
            else:
                log_error("upload.upload_to_r2 function reported a failure (returned False).")
                return False
        else:
            log_error("Error: 'upload.py' does not contain a callable 'upload_to_r2' function.")
            return False
    except ImportError as e:
        log_error(f"Failed to import upload.py: {e}. Make sure '{target_upload_script_path}' exists and is valid and not empty.")
        return False
    except Exception as e:
        log_error(f"An unexpected error occurred during cloud upload: {e}", include_traceback=True)
        return False
    finally:
        if SERVICE_BASE_DIR in sys.path:
            sys.path.remove(SERVICE_BASE_DIR)

def run_monitor_loop():
    """
    The main loop for the systemd service.
    Ensures tmate is running, updates URLs, and uploads them.
    """
    log_message("tmate monitor service started. Entering continuous monitoring loop.")
    tmate_pid = None

    while True:
        try:
            current_links, discovered_pid = get_current_tmate_session_info()

            if current_links and discovered_pid:
                if tmate_pid is None or tmate_pid != discovered_pid:
                    log_message(f"Detected new or confirmed existing tmate session (PID: {discovered_pid}).")
                    tmate_pid = discovered_pid
                    write_shs_file(current_links)
                    upload_urls_to_cloud()
                else:
                    log_message(f"tmate session (PID: {tmate_pid}) still active. No changes to links. Periodically re-uploading.")
                    upload_urls_to_cloud()
            else:
                log_warning("No active tmate session found or links could not be retrieved. Attempting to start a new one.")
                kill_cmd = f"pkill -f 'tmate -S'"
                if not run_command([kill_cmd], shell=True, sudo=True):
                    log_warning("pkill command encountered an unexpected error. Continuing anyway to attempt new tmate session.")
                time.sleep(2)

                new_links, new_pid = start_new_tmate_session()
                if new_links and new_pid:
                    log_message(f"Successfully started new tmate session (PID: {new_pid}).")
                    tmate_pid = new_pid
                    write_shs_file(new_links)
                    upload_urls_to_cloud()
                else:
                    log_error("Failed to start a new tmate session. Will retry after delay.")
                    tmate_pid = None

        except Exception as e:
            log_error(f"An unhandled error occurred in the main monitor loop: {e}", include_traceback=True)

        time.sleep(30)

def install_systemd_service():
    """
    Installs and enables the tmate_monitor systemd service.
    This function REQUIRES sudo privileges.
    Ensures content is up-to-date and avoids copying the main script.
    """
    log_message("Attempting to install systemd service (requires sudo)...")

    # 1. Create SERVICE_BASE_DIR
    if not run_command(["mkdir", "-p", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to create service directory {SERVICE_BASE_DIR}.")
        return False
    if not run_command(["chmod", "0755", SERVICE_BASE_DIR], sudo=True):
        log_error(f"Failed to set permissions for {SERVICE_BASE_DIR}.")
        return False

    current_script_path = os.path.abspath(__file__)
    current_script_dir = os.path.dirname(current_script_path)
    # target_script_path is now the *original* path of this script
    target_script_path = current_script_path # No longer copying this script

    # 2. Handle upload.py
    source_upload_script_path = os.path.join(current_script_dir, "upload.py")
    target_upload_script_path = os.path.join(SERVICE_BASE_DIR, "upload.py")

    file_needs_update = False
    if os.path.exists(source_upload_script_path):
        # User has provided their own upload.py, copy it.
        log_message(f"User-provided 'upload.py' found at '{source_upload_script_path}'. Copying to service directory.")
        try:
            # Check content if file exists, only copy if different to avoid unnecessary writes
            existing_upload_content = ""
            if os.path.exists(target_upload_script_path):
                with open(target_upload_script_path, 'r') as f:
                    existing_upload_content = f.read().strip()
            
            with open(source_upload_script_path, 'r') as f:
                source_content = f.read().strip()

            if existing_upload_content != source_content:
                if not run_command(["cp", source_upload_script_path, target_upload_script_path], sudo=True):
                    log_error(f"Failed to copy upload.py from {source_upload_script_path} to {target_upload_script_path}.")
                    return False
                if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
                    log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
                    return False
                log_message(f"'{target_upload_script_path}' updated and made executable.")
            else:
                log_message(f"'{target_upload_script_path}' is already up to date. Skipping copy.")
        except Exception as e:
            log_error(f"Error handling user-provided upload.py: {e}", include_traceback=True)
            return False
    else:
        # No user-provided upload.py, create dummy if not exists or if dummy content changed
        log_warning(f"'{source_upload_script_path}' not found. Managing placeholder '{target_upload_script_path}'.")
        
        existing_dummy_content = ""
        if os.path.exists(target_upload_script_path):
            try:
                with open(target_upload_script_path, 'r') as f:
                    existing_dummy_content = f.read().strip()
            except IOError as e:
                log_warning(f"Could not read existing dummy {target_upload_script_path}: {e}. Will attempt to overwrite.")
                file_needs_update = True
            
            if existing_dummy_content == DUMMY_UPLOAD_CONTENT.strip():
                log_message(f"Dummy '{target_upload_script_path}' is already up to date. Skipping creation.")
            else:
                log_message(f"Dummy '{target_upload_script_path}' content differs. Updating...")
                file_needs_update = True
        else:
            log_message(f"Dummy '{target_upload_script_path}' does not exist. Creating...")
            file_needs_update = True

        if file_needs_update:
            try:
                write_cmd = f"echo \"{DUMMY_UPLOAD_CONTENT.strip()}\" | sudo tee {target_upload_script_path}"
                if not run_command(write_cmd, shell=True):
                    log_error(f"Failed to create dummy upload.py at {target_upload_script_path}.")
                    return False
                if not run_command(["chmod", "0755", target_upload_script_path], sudo=True):
                    log_error(f"Failed to make upload.py executable at {target_upload_script_path}.")
                    return False
                log_message(f"Dummy '{target_upload_script_path}' created/updated.")
            except Exception as e:
                log_error(f"Error creating dummy upload.py: {e}", include_traceback=True)
                return False

    # 3. Create/Update Systemd Service File
    service_content = f"""
[Unit]
Description=tmate Session Monitor and Uploader
After=network-online.target

[Service]
ExecStart={sys.executable} {target_script_path} run_monitor
Restart=always
User=root
WorkingDirectory={SERVICE_BASE_DIR}
StandardOutput=journal
StandardError=journal
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin # Ensure tmate is in PATH for root

[Install]
WantedBy=multi-user.target
"""
    service_file_path = f"/etc/systemd/system/{SYSTEMD_SERVICE_NAME}"

    file_needs_update = False
    existing_service_content = ""
    if os.path.exists(service_file_path):
        try:
            with open(service_file_path, 'r') as f:
                existing_service_content = f.read().strip()
        except IOError as e:
            log_warning(f"Could not read existing {service_file_path}: {e}. Will attempt to overwrite.")
            file_needs_update = True
        
        if existing_service_content == service_content.strip():
            log_message(f"Systemd service file '{service_file_path}' is already up to date. Skipping write.")
            return True # Service file is good, no further action needed for this function
        else:
            log_message(f"Existing systemd service file '{service_file_path}' differs from desired content. Updating...")
            file_needs_update = True
    else:
        log_message(f"Systemd service file '{service_file_path}' does not exist. Creating...")
        file_needs_update = True

    if file_needs_update:
        log_message(f"Writing systemd service file at '{service_file_path}'...")
        try:
            with open(service_file_path, 'w') as f:
                f.write(service_content.strip() + "\n")
            os.chmod(service_file_path, 0o644)
            log_message(f"Service file '{service_file_path}' written directly and permissions set.")
        except IOError as e:
            log_error(f"Failed to write service file {service_file_path} directly via Python: {e}", include_traceback=True)
            log_warning("Attempting fallback to 'sudo tee' for service file creation.")
            escaped_content = service_content.strip().replace('"', '\\"')
            write_cmd = f"echo \"{escaped_content}\" | sudo tee {service_file_path}"
            if not run_command(write_cmd, shell=True):
                log_error(f"Failed to write service file to {service_file_path} even with 'sudo tee'. Check system permissions or disk issues.")
                return False
            log_message(f"Service file '{service_file_path}' written via 'sudo tee'.")
        except Exception as e:
            log_error(f"An unexpected error occurred creating systemd service file: {e}", include_traceback=True)
            return False

    if not os.path.exists(service_file_path):
        log_error(f"CRITICAL: Service file '{service_file_path}' was NOT found after creation attempt. Aborting setup.")
        return False
    else:
        log_message(f"Verification: Service file '{service_file_path}' found.")

    log_message("Reloading systemd daemon...")
    if not run_command(["systemctl", "daemon-reload"], sudo=True):
        log_error("Failed to reload systemd daemon.")
        return False

    log_message(f"Enabling service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "enable", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to enable service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Starting service '{SYSTEMD_SERVICE_NAME}'...")
    if not run_command(["systemctl", "start", SYSTEMD_SERVICE_NAME], sudo=True):
        log_error(f"Failed to start service '{SYSTEMD_SERVICE_NAME}'.")
        return False

    log_message(f"Systemd service '{SYSTEMD_SERVICE_NAME}' installed, enabled, and started successfully.")
    log_message("You can check its status with: sudo systemctl status tmate_monitor.service")
    log_message("You can view logs with: journalctl -u tmate_monitor.service -f")
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "run_monitor":
        if os.geteuid() != 0:
            log_error("Script is configured to run as root by systemd, but detected as non-root.")
            sys.exit(1)
        run_monitor_loop()
    else:
        print("\n" + "="*70)
        print(" Welcome to the tmate Persistent Session Setup Script ".center(70))
        print(" This script will install tmate system-wide, configure it, ".center(70))
        print(" and set up a systemd service to keep it running constantly. ".center(70))
        print(" ".center(70))
        print(" !!! THIS REQUIRES SUDO PRIVILEGES FOR SYSTEM-LEVEL CHANGES !!! ".center(70))
        print("=".center(70) + "\n")

        if os.geteuid() != 0:
            log_error("This script needs to be run with 'sudo' for initial setup and systemd service installation.")
            log_error("Please run: sudo python3 your_script_name.py")
            sys.exit(1)

        if not install_tmate_system_wide():
            log_error("Setup failed: tmate installation failed.")
            sys.exit(1)

        if not configure_tmate_keybindings():
            log_error("Setup failed: tmate configuration failed.")
            sys.exit(1)

        if not install_systemd_service():
            log_error("Setup failed: Systemd service installation failed.")
            sys.exit(1)

        log_message("Initial setup complete! The tmate monitor service should now be running in the background.")
        log_message("It will ensure tmate is always active and upload session URLs.")
        log_message("You can now close this terminal.")
        log_message("To remove the service later, run: sudo systemctl stop tmate_monitor.service && sudo systemctl disable tmate_monitor.service && sudo rm /etc/systemd/system/tmate_monitor.service && sudo rm -rf /opt/tmate_monitor")


#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
tmate-bootstrap: A comprehensive, all-in-one script to install, configure,
manage, and monitor a persistent tmate session as a systemd service.

This script is designed for maximum compatibility and robustness, relying only
on the Python standard library. It handles everything from downloading the
correct tmate binary to generating and managing the systemd service.
"""

import subprocess
import os
import time
import shutil
import platform
import sys
import urllib.request
import json
import tarfile
import traceback

# --- Global Configuration ---
TMATE_INSTALL_DIR = "/usr/local/bin"
SERVICE_BASE_DIR = "/opt/tmate_monitor"
TMATE_CONFIG_FILE = os.path.join(SERVICE_BASE_DIR, ".tmate.conf")
TMATE_SOCKET_PATH = "/tmp/tmate.sock"
URL_OUTPUT_FILE = os.path.join(SERVICE_BASE_DIR, "session_urls.txt")
UPLOAD_SCRIPT_PATH = os.path.join(SERVICE_BASE_DIR, "uploader.py")
SYSTEMD_SERVICE_NAME = "tmate-monitor.service"
SYSTEMD_SERVICE_PATH = f"/etc/systemd/system/{SYSTEMD_SERVICE_NAME}"
GITHUB_API_URL = "https://api.github.com/repos/tmate-io/tmate/releases/latest"

# --- Content for Generated Files ---

# A minimal tmate configuration to ensure non-interactive, predictable behavior.
TMATE_CONFIG_CONTENT = """
# Generated by tmate-bootstrap
set-option -g default-command "bash"
set -g display-time 4000
set -g escape-time 0
set -g remain-on-exit off
set -g status off
"""

# Placeholder for the user's cloud upload script.
UPLOADER_PLACEHOLDER_CONTENT = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
This is a placeholder for your cloud upload script.
You MUST replace the logic in `upload_file` with your actual implementation
for uploading to a service like Cloudflare R2, AWS S3, etc.
"""

import os
import sys

def upload_file(file_path):
    """
    Uploads the given file to your cloud storage.

    Args:
        file_path (str): The absolute path to the file to upload.

    Returns:
        bool: True on success, False on failure.
    """
    print(f"[UPLOADER] Simulating upload of {file_path}...")

    # --- START: YOUR CUSTOM UPLOAD LOGIC ---
    # This is where you implement the actual upload.
    # Example for Cloudflare R2 using boto3:
    #
    # Ensure you have boto3 installed: pip install boto3
    #
    # import boto3
    # from botocore.exceptions import NoCredentialsError, PartialCredentialsError
    #
    # try:
    #     account_id = os.environ.get("R2_ACCOUNT_ID")
    #     access_key_id = os.environ.get("R2_ACCESS_KEY_ID")
    #     access_key_secret = os.environ.get("R2_SECRET_ACCESS_KEY")
    #     bucket_name = os.environ.get("R2_BUCKET_NAME")
    #
    #     if not all([account_id, access_key_id, access_key_secret, bucket_name]):
    #         print("[UPLOADER_ERROR] Missing one or more R2 environment variables.", file=sys.stderr)
    #         return False
    #
    #     s3 = boto3.client(
    #         service_name='s3',
    #         endpoint_url=f'https://{account_id}.r2.cloudflarestorage.com',
    #         aws_access_key_id=access_key_id,
    #         aws_secret_access_key=access_key_secret,
    #         region_name='auto'
    #     )
    #
    #     object_name = os.path.basename(file_path)
    #     s3.upload_file(file_path, bucket_name, object_name)
    #     print(f"[UPLOADER] Successfully uploaded {object_name} to bucket {bucket_name}.")
    #     return True
    #
    # except (NoCredentialsError, PartialCredentialsError) as e:
    #     print(f"[UPLOADER_ERROR] Credentials error: {e}", file=sys.stderr)
    #     return False
    # except Exception as e:
    #     print(f"[UPLOADER_ERROR] An unexpected error occurred: {e}", file=sys.stderr)
    #     return False
    #
    # --- END: YOUR CUSTOM UPLOAD LOGIC ---

    print(f"[UPLOADER] Simulation complete. Remember to replace this with real logic.")
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1:
        upload_file(sys.argv[1])
    else:
        print("Usage: ./uploader.py <file_to_upload>")
'''

# --- Logging Utilities ---
def log(level, message, exc_info=False):
    """Unified logger."""
    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{level.upper()}] {timestamp} {message}", file=sys.stderr if level == 'error' else sys.stdout)
    if exc_info:
        traceback.print_exc(file=sys.stderr)

# --- Core Subprocess Runner ---
def run_cmd(cmd, check=True, timeout=60):
    """A wrapper for subprocess.run with unified logging and error handling."""
    try:
        log('cmd', f"Executing: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, check=check, timeout=timeout)
        if result.stdout:
            log('info', f"Stdout: {result.stdout.strip()}")
        return result.stdout.strip()
    except FileNotFoundError:
        log('error', f"Command not found: {cmd[0]}. Is it in your PATH?")
        return None
    except subprocess.CalledProcessError as e:
        log('error', f"Command '{' '.join(cmd)}' failed with exit code {e.returncode}.")
        if e.stderr:
            log('error', f"Stderr: {e.stderr.strip()}")
        return None
    except subprocess.TimeoutExpired:
        log('error', f"Command '{' '.join(cmd)}' timed out after {timeout} seconds.")
        return None
    except Exception:
        log('error', f"An unexpected exception occurred while running command.", exc_info=True)
        return None

# --- Action Functions ---

def action_install():
    """Downloads, extracts, and installs the latest tmate binary."""
    log('info', "Starting tmate installation...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False

    # 1. Determine correct binary URL
    try:
        log('info', "Fetching latest tmate release information from GitHub...")
        with urllib.request.urlopen(GITHUB_API_URL, timeout=20) as response:
            release_info = json.loads(response.read().decode())
    except Exception:
        log('error', "Failed to fetch or parse GitHub release data.", exc_info=True)
        return False

    system = platform.system()
    machine = platform.machine()
    arch_map = {"x86_64": "amd64", "aarch64": "arm64v8"} # Common mappings
    arch = arch_map.get(machine)

    if system != "Linux" or not arch:
        log('error', f"Unsupported OS/Architecture: {system}/{machine}.")
        return False

    asset_keyword = f"linux-{arch}"
    download_url = None
    for asset in release_info.get("assets", []):
        if asset_keyword in asset["name"] and asset["name"].endswith(".tar.xz"):
            download_url = asset["browser_download_url"]
            break

    if not download_url:
        log('error', f"Could not find a suitable tmate binary for your architecture ({arch}).")
        return False

    # 2. Clean up previous installation
    log('info', "Cleaning up old tmate processes and files...")
    subprocess.run(["pkill", "-f", "tmate"], check=False) # Best effort kill
    time.sleep(1)
    if os.path.exists(os.path.join(TMATE_INSTALL_DIR, "tmate")):
        os.remove(os.path.join(TMATE_INSTALL_DIR, "tmate"))

    # 3. Download and extract
    archive_path = f"/tmp/{download_url.split('/')[-1]}"
    extract_path = "/tmp/tmate_extract"
    try:
        log('info', f"Downloading from {download_url}...")
        urllib.request.urlretrieve(download_url, archive_path)
        if os.path.exists(extract_path):
            shutil.rmtree(extract_path)
        os.makedirs(extract_path)
        with tarfile.open(archive_path, "r:xz") as tar:
            tar.extractall(path=extract_path)

        # 4. Find and install binary
        extracted_binary = next((os.path.join(r, f) for r, _, files in os.walk(extract_path) for f in files if f == 'tmate'), None)
        if not extracted_binary:
            log('error', "Could not find 'tmate' executable in the downloaded archive.")
            return False

        log('info', f"Installing tmate to {TMATE_INSTALL_DIR}...")
        shutil.move(extracted_binary, os.path.join(TMATE_INSTALL_DIR, "tmate"))
        os.chmod(os.path.join(TMATE_INSTALL_DIR, "tmate"), 0o755)

    except Exception:
        log('error', "An error occurred during download or extraction.", exc_info=True)
        return False
    finally:
        if os.path.exists(archive_path): os.remove(archive_path)
        if os.path.exists(extract_path): shutil.rmtree(extract_path)

    # 5. Verify installation
    version = run_cmd([os.path.join(TMATE_INSTALL_DIR, "tmate"), "-V"])
    if version and "tmate" in version:
        log('info', f"tmate installation successful! Version: {version}")
        return True
    else:
        log('error', "tmate verification failed after installation.")
        return False

def action_setup_service():
    """Creates directories, config files, and the systemd service file."""
    log('info', "Setting up service directories and files...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False

    try:
        # Create base directory
        os.makedirs(SERVICE_BASE_DIR, 0o755, exist_ok=True)

        # Create tmate config file
        with open(TMATE_CONFIG_FILE, 'w') as f:
            f.write(TMATE_CONFIG_CONTENT)
        log('info', f"Created tmate config at {TMATE_CONFIG_FILE}")

        # Create placeholder uploader script
        if not os.path.exists(UPLOAD_SCRIPT_PATH):
            with open(UPLOAD_SCRIPT_PATH, 'w') as f:
                f.write(UPLOADER_PLACEHOLDER_CONTENT)
            os.chmod(UPLOAD_SCRIPT_PATH, 0o755)
            log('warning', f"Created placeholder uploader at {UPLOAD_SCRIPT_PATH}. You MUST edit it with your cloud credentials.")
        else:
            log('info', "Uploader script already exists, skipping creation.")
        
        # Create systemd service file content
        script_path = os.path.realpath(__file__)
        service_content = f"""[Unit]
Description=Persistent tmate Session Monitor
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
Group=root
ExecStart=/usr/bin/python3 {script_path} run
WorkingDirectory={SERVICE_BASE_DIR}
Environment="PYTHONUNBUFFERED=1"
Restart=always
RestartSec=30
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
"""
        with open(SYSTEMD_SERVICE_PATH, 'w') as f:
            f.write(service_content)
        log('info', f"Created systemd service file at {SYSTEMD_SERVICE_PATH}")

        # Reload systemd
        log('info', "Reloading systemd daemon...")
        run_cmd(["systemctl", "daemon-reload"])
        
        log('info', "\nSetup complete! To start the service, run:")
        log('info', f"  sudo systemctl enable --now {SYSTEMD_SERVICE_NAME}")
        return True
    except Exception:
        log('error', "An error occurred during service setup.", exc_info=True)
        return False

def action_run_monitor():
    """The main monitoring loop executed by the systemd service."""
    log('info', "tmate monitor started. Entering main loop...")
    while True:
        try:
            # Check for a running session by querying links
            keys = {"ssh": "#{tmate_ssh}", "web_ro": "#{tmate_web_ro}"}
            cmd = ["tmate", "-S", TMATE_SOCKET_PATH, "display", "-p", keys['ssh']]
            session_ok = run_cmd(cmd, check=False) is not None

            if not session_ok:
                log('warning', "tmate session not found or unresponsive. Attempting to start a new one.")
                subprocess.run(["pkill", "-f", "tmate"], check=False)
                if os.path.exists(TMATE_SOCKET_PATH): os.remove(TMATE_SOCKET_PATH)
                time.sleep(2)

                start_cmd = [
                    "tmate", "-S", TMATE_SOCKET_PATH,
                    "-f", TMATE_CONFIG_FILE,
                    "new-session", "-d"
                ]
                if run_cmd(start_cmd, check=False) is None:
                    log('error', "Failed to start new tmate session. Will retry.")
                    time.sleep(60)
                    continue
                
                log('info', "New session created. Waiting for it to connect...")
                time.sleep(15) # Give time for keys to be generated

            # Retrieve all links
            links = {}
            for name, key in keys.items():
                cmd = ["tmate", "-S", TMATE_SOCKET_PATH, "display", "-p", key]
                link = run_cmd(cmd)
                if link: links[name] = link
            
            if len(links) == len(keys):
                log('info', "Successfully retrieved session URLs.")
                content = "\n".join([f"{k}: {v}" for k, v in links.items()])
                with open(URL_OUTPUT_FILE, 'w') as f: f.write(content + "\n")
                
                # Attempt to upload
                if os.path.exists(UPLOAD_SCRIPT_PATH):
                    log('info', "Executing uploader script...")
                    run_cmd([UPLOAD_SCRIPT_PATH, URL_OUTPUT_FILE])
            else:
                log('error', "Failed to retrieve all session links after start. The session may be unstable.")

        except Exception:
            log('error', "An unhandled error occurred in the monitor loop.", exc_info=True)

        log('info', f"Check complete. Next check in 5 minutes.")
        time.sleep(300)

def action_uninstall():
    """Completely removes the tmate binary, service, and all related files."""
    log('info', "Starting uninstallation...")
    if os.geteuid() != 0:
        log('error', "This action requires root privileges. Please run with sudo.")
        return False

    # 1. Stop and disable the service
    if os.path.exists(SYSTEMD_SERVICE_PATH):
        log('info', f"Stopping and disabling {SYSTEMD_SERVICE_NAME} service...")
        run_cmd(["systemctl", "stop", SYSTEMD_SERVICE_NAME], check=False)
        run_cmd(["systemctl", "disable", SYSTEMD_SERVICE_NAME], check=False)
        os.remove(SYSTEMD_SERVICE_PATH)
        run_cmd(["systemctl", "daemon-reload"])
        run_cmd(["systemctl", "reset-failed"], check=False)

    # 2. Kill all tmate processes
    log('info', "Terminating any running tmate processes...")
    subprocess.run(["pkill", "-f", "tmate"], check=False)

    # 3. Remove files
    tmate_binary = os.path.join(TMATE_INSTALL_DIR, "tmate")
    if os.path.exists(tmate_binary):
        log('info', f"Removing tmate binary: {tmate_binary}")
        os.remove(tmate_binary)

    if os.path.exists(SERVICE_BASE_DIR):
        log('info', f"Removing service directory: {SERVICE_BASE_DIR}")
        shutil.rmtree(SERVICE_BASE_DIR)

    if os.path.exists(TMATE_SOCKET_PATH):
        os.remove(TMATE_SOCKET_PATH)

    log('info', "Uninstallation complete.")
    return True

def main():
    """Main command-line interface."""
    actions = {
        "install": action_install,
        "setup-service": action_setup_service,
        "run": action_run_monitor,
        "uninstall": action_uninstall
    }
    
    if len(sys.argv) < 2 or sys.argv[1] not in actions:
        print("tmate-bootstrap: All-in-one tmate service manager")
        print("\nUsage: sudo ./tmate_monitor.py [ACTION]")
        print("\nActions:")
        print("  install        - Downloads and installs the latest tmate binary.")
        print("  setup-service  - Creates configs and the systemd service file.")
        print("  run            - Starts the monitoring loop (used by the service).")
        print("  uninstall      - Removes the tmate binary and all service files.")
        print("\nRecommended Workflow:")
        print("  1. sudo ./tmate_monitor.py install")
        print("  2. sudo ./tmate_monitor.py setup-service")
        print("  3. Edit /opt/tmate_monitor/uploader.py with your cloud credentials.")
        print("  4. sudo systemctl enable --now tmate-monitor.service")
        sys.exit(1)

    action = sys.argv[1]
    func = actions[action]
    if not func():
        log('error', f"Action '{action}' failed. Please check the logs above.")
        sys.exit(1)
    log('info', f"Action '{action}' completed successfully.")

if __name__ == "__main__":
    main()
